
    // DO NOT EDIT THIS FILE DIRECTLY. It is created by make_commonfunc_stan.py.

    // ========================================================================
    // Common functions
    // ========================================================================
    /*
        Reminders:
        - Annoyingly, you can't modify arguments to Stan user-defined
          functions. (No pass-by-reference.)
        - size() doesn't work on a plain "vector". Use num_elements().
        - Array/vector indexing is 1-based.
        - The addition-assignment (+=) operator generally doesn't work (it
          appears to be reserved for the one variable "target += ...").
          Similarly for all others you might expect.
        - Can't define constants in a functions{} block.
    */

    // ------------------------------------------------------------------------
    // Simple functions: softmax
    // ------------------------------------------------------------------------
    
    real softmaxNth(vector softmax_inputs, int index)
    {
        /*
            Returns the nth value (at "index") of the softmax of the inputs.
            Assumes an inverse temperature of 1.

        NOTES:
            A softmax function takes several inputs and normalizes them so 
            that:
                - the outputs are in the same relative order as the inputs
                - the outputs sum to 1.
            
            For softmax: see my miscstat.R; the important points for
            optimization are (1) that softmax is invariant to the addition/
            subtraction of a constant, and subtracting the mean makes the
            numbers less likely to fall over computationally; (2) we only
            need the final part of the computation for a single number
            (preference for the right), so we don't have to waste time
            vector-calculating the preference for the left as well [that is:
            we don't have to calculate s_exp_products / sum(s_exp_products)].
            
            The constant can be the mean, or the max; Stan uses the max, which
            is probably a little more efficient.

            Since Stan 2.0.0, the alternative is to use softmax(); see
            https://github.com/stan-dev/math/blob/develop/stan/math/prim/mat/fun/softmax.hpp
            The exact syntactic equivalence is:
            
                real result = softmaxNth(inputs, index);
                real result = softmax(inputs)[index];
        */
        int length = num_elements(softmax_inputs);
        real constant = max(softmax_inputs);
        vector[length] s_exp_products = exp(softmax_inputs - constant);
        return s_exp_products[index] / sum(s_exp_products);
    }

    real softmaxNthInvTemp(vector softmax_inputs, real inverse_temp, int index)
    {
        /*
            Version of softmaxNth allowing you to specify the inverse temp.
            
            The direct Stan equivalent is:
            
                real result = softmaxNthInvTemp(inputs, invtemp, index);
                real result = softmax(inputs * invtemp)[index];
        */
        
        return softmaxNth(softmax_inputs * inverse_temp, index);
    }

    real logitSoftmaxNth(vector inputs, int index)
    {
        // Returns logit(softmax(inputs))[index].

        // METHOD 1 (fewer calculations involved):
        real log_p = inputs[index] - log_sum_exp(inputs);
        
        // METHOD 2:
        // real log_p = log_softmax(inputs)[index];

        // EITHER WAY:
        real log_1mp = log1m_exp(log_p);  // = log(1 - exp(log_p)) = log(1 - p)
        return log_p - log_1mp;  // logit = log(p) - log(1 - p)
    }
    
    // ------------------------------------------------------------------------
    // Simple functions: logistic
    // ------------------------------------------------------------------------

    // For the logit function, use Stan's built-in logit().
    
    real logistic(real x, real x0, real k, real L)
    {
        // Returns x transformed through a logistic function.
        // Notation as per https://en.wikipedia.org/wiki/Logistic_function
        // x0: centre
        // k: steepness
        // L: maximum (usually 1)

        return L / (1 + exp(-k * (x - x0)));
        
        // If you were to transform x so as to be a logit giving the same
        // result via the standard logistic function, 1 / (1 + exp(-x)), for
        // L = 1, you want this logit:
        //      k * (x - x0) 
    }
    
    // For the standard logistic (with x0 = 0, k = 1, L = 1), use Stan's
    // inv_logit(). 

    // ------------------------------------------------------------------------
    // Simple functions: boundaries (min, max)
    // ------------------------------------------------------------------------

    real bound(real x, real min_value, real max_value)
    {
        // Returns x with minimum/maximum boundaries applied.
        // We should simply be able to do this:
        //     return max(min_value, min(x, max_value));
        // ... but Stan doesn't have max(real, real) or min(real, real) 
        // functions!

        if (x < min_value) {
            return min_value;
        } else if (x > max_value) {
            return max_value;
        } else {
            return x;
        }
    }

    real boundLower(real x, real min_value)
    {
        // a.k.a. max()

        if (x < min_value) {
            return min_value;
        } else {
            return x;
        }
    }

    real boundUpper(real x, real max_value)
    {
        // a.k.a. min()

        if (x > max_value) {
            return max_value;
        } else {
            return x;
        }
    }

    // ------------------------------------------------------------------------
    // LOG PROBABILITY FUNCTIONS FOR BRIDGE SAMPLING
    // ------------------------------------------------------------------------
    /*
    We can have functions that access the log probability accumulator
    if the function name ends in '_lp'; see Stan manual section 23.3.

    RE ARGUMENTS:

    The Stan manual uses notation like
         real normal_lpdf(reals y | reals mu, reals sigma)
    but "reals" isn't something you can actually use in user functions.
    See p495:
        "reals" means:
                real
                real[]
                vector
                row_vector
        "ints" means
                int
                int[]

    Moreover, you can't define two copies of the same function with
    different names (23.6: no overloading of user-defined functions).
    For real arguments, the options are therefore:
         real
         real[]  // one-dimensional array
         real[,]  // two-dimensional array
         real[,,]  // three-dimensional array (... etc.)
         vector  // vector, similar to a one-dimensional array.
         matrix  // matrix, similar to a two-dimensional array.
    See p297 of the 2017 Stan manual, and also p319.
    Which do we use in practice?
    - Firstly, we use single numbers or one-dimensional collections,
      and generally the latter. So that means real[] or vector.
    - We use both.
    - So let's have "Real", "Arr" and "Vec" versions.
    - Then, to make things worse, we sometimes have constant parameters,
      and sometimes array/vector parameters...
    - For something with two distribution parameters, like the normal
      distribution and many others, that means that we have 3*3*3 combinations
      for each thing. Urgh. Stan should allow user overloading ;).
    - Let's do it and define "R", "A", "2", "3", "V" for the parameters
    - Except we won't be returning R unless it's RRR!
    - Last thing cycles fastest.
    So:
        RRR
        -- nothing else R*

        ARA
        ARV
        AAR
        AAA
        AAV
        AVR
        AVA
        AVV

        2RR
            ...

        3RR
            ...

        VRA
        VRV
        VAR
        VAA
        VAV
        VVR
        VVA
        VVV

    RE SAMPLING TWO-DIMENSIONAL ARRAYS:

    You can't sample an entire matrix or 2D array; you have do to it row-wise.
    - This isn't very clear in the manual, as far as I can see.
    - The definition of e.g. beta_lpdf() is in terms of "reals", which
      probably means a vector or array of real.
    - Section 9.6 ("Multi-logit regression") of the Stan manual v2.16.0
      gives an example where one would use a matrix sampling statement but
      they don't.
    - But it is explicit in the sense that they define what they mean by
      "reals", as above, and that doesn't include 2D arrays.
    - Better to move the boilerplate code here than in user land, though.

    RE TWO-DIMENSIONAL ARRAYS:

        real thing[N_A, N_B];

        // One way to iterate through all elements:
        for (a in 1:N_A) {
            for (b in 1:N_B) {
                do_something(thing[a, b]);
            }
        }

        // NOT another way to iterate through all elements:
        for (i in 1:num_elements(thing)) {
            do_something(thing[i]);  // thing[i] is a real[], not a real
            // ... and thing[num_elements(thing)] will be an index overflow
        }

    So for some functions we want real[,]... let's give this the one-character
    notation "2" (for 2D array).

    Now:
        num_elements() gives the total, in this case N_A * N_B;
            ... but when *accessing* a 2D array, my_array[1] gives the first
                row, not the first element; see Stan 2017 manual p323.
        size() gives the size of first dimension, in this case N_A;
        dims() gives all dimensions, in this case an int[] containing {N_A, N_B}.

    RE ARITHMETIC:

    Note that we cannot do:
            real * real[]
            vector * vector

    */

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Helper functions for boundary checking
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // See Stan (2017) manual p82.
    // These are internal functions that ASSUME size match.
    // We can't use a leading "_" prefix on function names (Stan syntax error).

    // Lower

    void enforceLowerBound_R_lp(real y, real lower)
    {
        if (y < lower) {
            target += negative_infinity();
        }
    }
    void enforceLowerBound_A_lp(real[] y, real lower)
    {
        int length = num_elements(y);
        for (i in 1:length) {
            if (y[i] < lower) {
                target += negative_infinity();
            }
        }
    }
    void enforceLowerBound_2_lp(real[,] y, real lower)
    {
        int dimensions[2] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                if (y[i, j] < lower) {
                    target += negative_infinity();
                }
            }
        }
    }
    void enforceLowerBound_3_lp(real[,,] y, real lower)
    {
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    if (y[i, j, k] < lower) {
                        target += negative_infinity();
                    }
                }
            }
        }
    }
    void enforceLowerBound_V_lp(vector y, real lower)
    {
        int length = num_elements(y);
        for (i in 1:length) {
            if (y[i] < lower) {
                target += negative_infinity();
            }
        }
    }

    // Upper

    void enforceUpperBound_R_lp(real y, real upper)
    {
        if (y > upper) {
            target += negative_infinity();
        }
    }
    void enforceUpperBound_A_lp(real[] y, real upper)
    {
        int length = num_elements(y);
        for (i in 1:length) {
            if (y[i] > upper) {
                target += negative_infinity();
            }
        }
    }
    void enforceUpperBound_2_lp(real[,] y, real upper)
    {
        int dimensions[2] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                if (y[i, j] > upper) {
                    target += negative_infinity();
                }
            }
        }
    }
    void enforceUpperBound_3_lp(real[,,] y, real upper)
    {
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    if (y[i, j, k] > upper) {
                        target += negative_infinity();
                    }
                }
            }
        }
    }
    void enforceUpperBound_V_lp(vector y, real upper)
    {
        int length = num_elements(y);
        for (i in 1:length) {
            if (y[i] > upper) {
                target += negative_infinity();
            }
        }
    }

    // Range

    void enforceRangeBounds_R_lp(real y, real lower, real upper)
    {
        if (y < lower || y > upper) {
            target += negative_infinity();
        }
    }
    void enforceRangeBounds_A_lp(real[] y, real lower, real upper)
    {
        int length = num_elements(y);
        for (i in 1:length) {
            real value = y[i];  // lookup only once
            if (value < lower || value > upper) {
                target += negative_infinity();
            }
        }
    }
    void enforceRangeBounds_2_lp(real[,] y, real lower, real upper)
    {
        int dimensions[2] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                real value = y[i, j];  // lookup only once
                if (value < lower || value > upper) {
                    target += negative_infinity();
                }
            }
        }
    }
    void enforceRangeBounds_3_lp(real[,,] y, real lower, real upper)
    {
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    real value = y[i, j, k];  // lookup only once
                    if (value < lower || value > upper) {
                        target += negative_infinity();
                    }
                }
            }
        }
    }
    void enforceRangeBounds_V_lp(vector y, real lower, real upper)
    {
        int length = num_elements(y);
        for (i in 1:length) {
            real value = y[i];  // lookup only once
            if (value < lower || value > upper) {
                target += negative_infinity();
            }
        }
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Normal distribution
    // - mu is the mean; sigma is the standard deviation
    // - See Stan 2.16.0 manual p512;
    //   http://mathworld.wolfram.com/NormalDistribution.html
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    // Sampling
    
    void sampleNormal_RRR_lp(real y, real mu, real sigma)
    {
        target += normal_lpdf(y | mu, sigma);
    }
    
    void sampleNormal_ARR_lp(real[] y, real mu, real sigma)
    {
        target += normal_lpdf(y | mu, sigma);
    }
    
    void sampleNormal_2RR_lp(real[,] y, real mu, real sigma)
    {
        int nrows = size(y);
        for (i in 1:nrows) {
            target += normal_lpdf(y[i] | mu, sigma);
            // ... y[i] is a one-dimensional array
        }
    }
    
    void sampleNormal_3RR_lp(real[,,] y, real mu, real sigma)
    {
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += normal_lpdf(y[i, j, k] | mu, sigma);
                }
            }
        }
    }
    
    void sampleNormal_VRR_lp(vector y, real mu, real sigma)
    {
        target += normal_lpdf(y | mu, sigma);
    }
    
    // Sampling with lower bound
    
    void sampleNormalLowerBound_RRR_lp(real y, real mu, real sigma, real lower)
    {
        real correction_per_value = normal_lccdf(lower | mu, sigma);
        target += normal_lpdf(y | mu, sigma) -
                  correction_per_value;
        enforceLowerBound_R_lp(y, lower);
    }
    
    void sampleNormalLowerBound_ARR_lp(real[] y, real mu, real sigma, real lower)
    {
        real correction_per_value = normal_lccdf(lower | mu, sigma);
        target += normal_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceLowerBound_A_lp(y, lower);
    }
    
    void sampleNormalLowerBound_2RR_lp(real[,] y, real mu, real sigma, real lower)
    {
        real correction_per_value = normal_lccdf(lower | mu, sigma);
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += normal_lpdf(y[i] | mu, sigma) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceLowerBound_2_lp(y, lower);
    }
    
    void sampleNormalLowerBound_3RR_lp(real[,,] y, real mu, real sigma, real lower)
    {
        real correction_per_value = normal_lccdf(lower | mu, sigma);
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += normal_lpdf(y[i, j, k] | mu, sigma) -
                              correction_per_value;
                }
            }
        }
        enforceLowerBound_3_lp(y, lower);
    }
    
    void sampleNormalLowerBound_VRR_lp(vector y, real mu, real sigma, real lower)
    {
        real correction_per_value = normal_lccdf(lower | mu, sigma);
        target += normal_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceLowerBound_V_lp(y, lower);
    }
    
    // Sampling with upper bound
    
    void sampleNormalUpperBound_RRR_lp(real y, real mu, real sigma, real upper)
    {
        real correction_per_value = normal_lcdf(upper | mu, sigma);
        target += normal_lpdf(y | mu, sigma) -
                  correction_per_value;
        enforceUpperBound_R_lp(y, upper);
    }
    
    void sampleNormalUpperBound_ARR_lp(real[] y, real mu, real sigma, real upper)
    {
        real correction_per_value = normal_lcdf(upper | mu, sigma);
        target += normal_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceUpperBound_A_lp(y, upper);
    }
    
    void sampleNormalUpperBound_2RR_lp(real[,] y, real mu, real sigma, real upper)
    {
        real correction_per_value = normal_lcdf(upper | mu, sigma);
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += normal_lpdf(y[i] | mu, sigma) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceUpperBound_2_lp(y, upper);
    }
    
    void sampleNormalUpperBound_3RR_lp(real[,,] y, real mu, real sigma, real upper)
    {
        real correction_per_value = normal_lcdf(upper | mu, sigma);
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += normal_lpdf(y[i, j, k] | mu, sigma) -
                              correction_per_value;
                }
            }
        }
        enforceUpperBound_3_lp(y, upper);
    }
    
    void sampleNormalUpperBound_VRR_lp(vector y, real mu, real sigma, real upper)
    {
        real correction_per_value = normal_lcdf(upper | mu, sigma);
        target += normal_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceUpperBound_V_lp(y, upper);
    }
    
    // Sampling with range (lower and upper) bounds
    
    void sampleNormalRangeBound_RRR_lp(real y, real mu, real sigma, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            normal_lcdf(upper | mu, sigma),
            normal_lcdf(lower | mu, sigma));
        target += normal_lpdf(y | mu, sigma) -
                  correction_per_value;
        enforceRangeBounds_R_lp(y, lower, upper);
    }
    
    void sampleNormalRangeBound_ARR_lp(real[] y, real mu, real sigma, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            normal_lcdf(upper | mu, sigma),
            normal_lcdf(lower | mu, sigma));
        target += normal_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceRangeBounds_A_lp(y, lower, upper);
    }
    
    void sampleNormalRangeBound_2RR_lp(real[,] y, real mu, real sigma, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            normal_lcdf(upper | mu, sigma),
            normal_lcdf(lower | mu, sigma));
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += normal_lpdf(y[i] | mu, sigma) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceRangeBounds_2_lp(y, lower, upper);
    }
    
    void sampleNormalRangeBound_3RR_lp(real[,,] y, real mu, real sigma, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            normal_lcdf(upper | mu, sigma),
            normal_lcdf(lower | mu, sigma));
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += normal_lpdf(y[i, j, k] | mu, sigma) -
                              correction_per_value;
                }
            }
        }
        enforceRangeBounds_3_lp(y, lower, upper);
    }
    
    void sampleNormalRangeBound_VRR_lp(vector y, real mu, real sigma, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            normal_lcdf(upper | mu, sigma),
            normal_lcdf(lower | mu, sigma));
        target += normal_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceRangeBounds_V_lp(y, lower, upper);
    }
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Cauchy distribution
    // - mu is location parameter; sigma is scale parameter
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    // Sampling
    
    void sampleCauchy_RRR_lp(real y, real mu, real sigma)
    {
        target += cauchy_lpdf(y | mu, sigma);
    }
    
    void sampleCauchy_ARR_lp(real[] y, real mu, real sigma)
    {
        target += cauchy_lpdf(y | mu, sigma);
    }
    
    void sampleCauchy_2RR_lp(real[,] y, real mu, real sigma)
    {
        int nrows = size(y);
        for (i in 1:nrows) {
            target += cauchy_lpdf(y[i] | mu, sigma);
            // ... y[i] is a one-dimensional array
        }
    }
    
    void sampleCauchy_3RR_lp(real[,,] y, real mu, real sigma)
    {
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += cauchy_lpdf(y[i, j, k] | mu, sigma);
                }
            }
        }
    }
    
    void sampleCauchy_VRR_lp(vector y, real mu, real sigma)
    {
        target += cauchy_lpdf(y | mu, sigma);
    }
    
    // Sampling with lower bound
    
    void sampleCauchyLowerBound_RRR_lp(real y, real mu, real sigma, real lower)
    {
        real correction_per_value = cauchy_lccdf(lower | mu, sigma);
        target += cauchy_lpdf(y | mu, sigma) -
                  correction_per_value;
        enforceLowerBound_R_lp(y, lower);
    }
    
    void sampleCauchyLowerBound_ARR_lp(real[] y, real mu, real sigma, real lower)
    {
        real correction_per_value = cauchy_lccdf(lower | mu, sigma);
        target += cauchy_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceLowerBound_A_lp(y, lower);
    }
    
    void sampleCauchyLowerBound_2RR_lp(real[,] y, real mu, real sigma, real lower)
    {
        real correction_per_value = cauchy_lccdf(lower | mu, sigma);
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += cauchy_lpdf(y[i] | mu, sigma) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceLowerBound_2_lp(y, lower);
    }
    
    void sampleCauchyLowerBound_3RR_lp(real[,,] y, real mu, real sigma, real lower)
    {
        real correction_per_value = cauchy_lccdf(lower | mu, sigma);
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += cauchy_lpdf(y[i, j, k] | mu, sigma) -
                              correction_per_value;
                }
            }
        }
        enforceLowerBound_3_lp(y, lower);
    }
    
    void sampleCauchyLowerBound_VRR_lp(vector y, real mu, real sigma, real lower)
    {
        real correction_per_value = cauchy_lccdf(lower | mu, sigma);
        target += cauchy_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceLowerBound_V_lp(y, lower);
    }
    
    // Sampling with upper bound
    
    void sampleCauchyUpperBound_RRR_lp(real y, real mu, real sigma, real upper)
    {
        real correction_per_value = cauchy_lcdf(upper | mu, sigma);
        target += cauchy_lpdf(y | mu, sigma) -
                  correction_per_value;
        enforceUpperBound_R_lp(y, upper);
    }
    
    void sampleCauchyUpperBound_ARR_lp(real[] y, real mu, real sigma, real upper)
    {
        real correction_per_value = cauchy_lcdf(upper | mu, sigma);
        target += cauchy_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceUpperBound_A_lp(y, upper);
    }
    
    void sampleCauchyUpperBound_2RR_lp(real[,] y, real mu, real sigma, real upper)
    {
        real correction_per_value = cauchy_lcdf(upper | mu, sigma);
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += cauchy_lpdf(y[i] | mu, sigma) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceUpperBound_2_lp(y, upper);
    }
    
    void sampleCauchyUpperBound_3RR_lp(real[,,] y, real mu, real sigma, real upper)
    {
        real correction_per_value = cauchy_lcdf(upper | mu, sigma);
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += cauchy_lpdf(y[i, j, k] | mu, sigma) -
                              correction_per_value;
                }
            }
        }
        enforceUpperBound_3_lp(y, upper);
    }
    
    void sampleCauchyUpperBound_VRR_lp(vector y, real mu, real sigma, real upper)
    {
        real correction_per_value = cauchy_lcdf(upper | mu, sigma);
        target += cauchy_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceUpperBound_V_lp(y, upper);
    }
    
    // Sampling with range (lower and upper) bounds
    
    void sampleCauchyRangeBound_RRR_lp(real y, real mu, real sigma, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            cauchy_lcdf(upper | mu, sigma),
            cauchy_lcdf(lower | mu, sigma));
        target += cauchy_lpdf(y | mu, sigma) -
                  correction_per_value;
        enforceRangeBounds_R_lp(y, lower, upper);
    }
    
    void sampleCauchyRangeBound_ARR_lp(real[] y, real mu, real sigma, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            cauchy_lcdf(upper | mu, sigma),
            cauchy_lcdf(lower | mu, sigma));
        target += cauchy_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceRangeBounds_A_lp(y, lower, upper);
    }
    
    void sampleCauchyRangeBound_2RR_lp(real[,] y, real mu, real sigma, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            cauchy_lcdf(upper | mu, sigma),
            cauchy_lcdf(lower | mu, sigma));
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += cauchy_lpdf(y[i] | mu, sigma) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceRangeBounds_2_lp(y, lower, upper);
    }
    
    void sampleCauchyRangeBound_3RR_lp(real[,,] y, real mu, real sigma, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            cauchy_lcdf(upper | mu, sigma),
            cauchy_lcdf(lower | mu, sigma));
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += cauchy_lpdf(y[i, j, k] | mu, sigma) -
                              correction_per_value;
                }
            }
        }
        enforceRangeBounds_3_lp(y, lower, upper);
    }
    
    void sampleCauchyRangeBound_VRR_lp(vector y, real mu, real sigma, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            cauchy_lcdf(upper | mu, sigma),
            cauchy_lcdf(lower | mu, sigma));
        target += cauchy_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceRangeBounds_V_lp(y, lower, upper);
    }
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Beta distribution
    // - in R, alpha is called scale1, and beta is called scale2
    // - Stan 2.16.0 manual p532; R ?dbeta;
    //   https://www.rdocumentation.org/packages/visualize/versions/4.3.0/topics/visualize.beta
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    // Sampling
    
    void sampleBeta_RRR_lp(real y, real alpha, real beta)
    {
        target += beta_lpdf(y | alpha, beta);
    }
    
    void sampleBeta_ARR_lp(real[] y, real alpha, real beta)
    {
        target += beta_lpdf(y | alpha, beta);
    }
    
    void sampleBeta_2RR_lp(real[,] y, real alpha, real beta)
    {
        int nrows = size(y);
        for (i in 1:nrows) {
            target += beta_lpdf(y[i] | alpha, beta);
            // ... y[i] is a one-dimensional array
        }
    }
    
    void sampleBeta_3RR_lp(real[,,] y, real alpha, real beta)
    {
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += beta_lpdf(y[i, j, k] | alpha, beta);
                }
            }
        }
    }
    
    void sampleBeta_VRR_lp(vector y, real alpha, real beta)
    {
        target += beta_lpdf(y | alpha, beta);
    }
    
    // Sampling with lower bound
    
    void sampleBetaLowerBound_RRR_lp(real y, real alpha, real beta, real lower)
    {
        real correction_per_value = beta_lccdf(lower | alpha, beta);
        target += beta_lpdf(y | alpha, beta) -
                  correction_per_value;
        enforceLowerBound_R_lp(y, lower);
    }
    
    void sampleBetaLowerBound_ARR_lp(real[] y, real alpha, real beta, real lower)
    {
        real correction_per_value = beta_lccdf(lower | alpha, beta);
        target += beta_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceLowerBound_A_lp(y, lower);
    }
    
    void sampleBetaLowerBound_2RR_lp(real[,] y, real alpha, real beta, real lower)
    {
        real correction_per_value = beta_lccdf(lower | alpha, beta);
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += beta_lpdf(y[i] | alpha, beta) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceLowerBound_2_lp(y, lower);
    }
    
    void sampleBetaLowerBound_3RR_lp(real[,,] y, real alpha, real beta, real lower)
    {
        real correction_per_value = beta_lccdf(lower | alpha, beta);
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += beta_lpdf(y[i, j, k] | alpha, beta) -
                              correction_per_value;
                }
            }
        }
        enforceLowerBound_3_lp(y, lower);
    }
    
    void sampleBetaLowerBound_VRR_lp(vector y, real alpha, real beta, real lower)
    {
        real correction_per_value = beta_lccdf(lower | alpha, beta);
        target += beta_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceLowerBound_V_lp(y, lower);
    }
    
    // Sampling with upper bound
    
    void sampleBetaUpperBound_RRR_lp(real y, real alpha, real beta, real upper)
    {
        real correction_per_value = beta_lcdf(upper | alpha, beta);
        target += beta_lpdf(y | alpha, beta) -
                  correction_per_value;
        enforceUpperBound_R_lp(y, upper);
    }
    
    void sampleBetaUpperBound_ARR_lp(real[] y, real alpha, real beta, real upper)
    {
        real correction_per_value = beta_lcdf(upper | alpha, beta);
        target += beta_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceUpperBound_A_lp(y, upper);
    }
    
    void sampleBetaUpperBound_2RR_lp(real[,] y, real alpha, real beta, real upper)
    {
        real correction_per_value = beta_lcdf(upper | alpha, beta);
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += beta_lpdf(y[i] | alpha, beta) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceUpperBound_2_lp(y, upper);
    }
    
    void sampleBetaUpperBound_3RR_lp(real[,,] y, real alpha, real beta, real upper)
    {
        real correction_per_value = beta_lcdf(upper | alpha, beta);
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += beta_lpdf(y[i, j, k] | alpha, beta) -
                              correction_per_value;
                }
            }
        }
        enforceUpperBound_3_lp(y, upper);
    }
    
    void sampleBetaUpperBound_VRR_lp(vector y, real alpha, real beta, real upper)
    {
        real correction_per_value = beta_lcdf(upper | alpha, beta);
        target += beta_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceUpperBound_V_lp(y, upper);
    }
    
    // Sampling with range (lower and upper) bounds
    
    void sampleBetaRangeBound_RRR_lp(real y, real alpha, real beta, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            beta_lcdf(upper | alpha, beta),
            beta_lcdf(lower | alpha, beta));
        target += beta_lpdf(y | alpha, beta) -
                  correction_per_value;
        enforceRangeBounds_R_lp(y, lower, upper);
    }
    
    void sampleBetaRangeBound_ARR_lp(real[] y, real alpha, real beta, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            beta_lcdf(upper | alpha, beta),
            beta_lcdf(lower | alpha, beta));
        target += beta_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceRangeBounds_A_lp(y, lower, upper);
    }
    
    void sampleBetaRangeBound_2RR_lp(real[,] y, real alpha, real beta, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            beta_lcdf(upper | alpha, beta),
            beta_lcdf(lower | alpha, beta));
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += beta_lpdf(y[i] | alpha, beta) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceRangeBounds_2_lp(y, lower, upper);
    }
    
    void sampleBetaRangeBound_3RR_lp(real[,,] y, real alpha, real beta, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            beta_lcdf(upper | alpha, beta),
            beta_lcdf(lower | alpha, beta));
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += beta_lpdf(y[i, j, k] | alpha, beta) -
                              correction_per_value;
                }
            }
        }
        enforceRangeBounds_3_lp(y, lower, upper);
    }
    
    void sampleBetaRangeBound_VRR_lp(vector y, real alpha, real beta, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            beta_lcdf(upper | alpha, beta),
            beta_lcdf(lower | alpha, beta));
        target += beta_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceRangeBounds_V_lp(y, lower, upper);
    }
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Gamma distribution
    // - Stan's alpha is R's shape; Stan's beta is R's rate.
    //   (R also offers scale = 1/rate.)
    // - https://en.wikipedia.org/wiki/Gamma_distribution
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    // Sampling
    
    void sampleGamma_RRR_lp(real y, real alpha, real beta)
    {
        target += gamma_lpdf(y | alpha, beta);
    }
    
    void sampleGamma_ARR_lp(real[] y, real alpha, real beta)
    {
        target += gamma_lpdf(y | alpha, beta);
    }
    
    void sampleGamma_2RR_lp(real[,] y, real alpha, real beta)
    {
        int nrows = size(y);
        for (i in 1:nrows) {
            target += gamma_lpdf(y[i] | alpha, beta);
            // ... y[i] is a one-dimensional array
        }
    }
    
    void sampleGamma_3RR_lp(real[,,] y, real alpha, real beta)
    {
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += gamma_lpdf(y[i, j, k] | alpha, beta);
                }
            }
        }
    }
    
    void sampleGamma_VRR_lp(vector y, real alpha, real beta)
    {
        target += gamma_lpdf(y | alpha, beta);
    }
    
    // Sampling with lower bound
    
    void sampleGammaLowerBound_RRR_lp(real y, real alpha, real beta, real lower)
    {
        real correction_per_value = gamma_lccdf(lower | alpha, beta);
        target += gamma_lpdf(y | alpha, beta) -
                  correction_per_value;
        enforceLowerBound_R_lp(y, lower);
    }
    
    void sampleGammaLowerBound_ARR_lp(real[] y, real alpha, real beta, real lower)
    {
        real correction_per_value = gamma_lccdf(lower | alpha, beta);
        target += gamma_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceLowerBound_A_lp(y, lower);
    }
    
    void sampleGammaLowerBound_2RR_lp(real[,] y, real alpha, real beta, real lower)
    {
        real correction_per_value = gamma_lccdf(lower | alpha, beta);
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += gamma_lpdf(y[i] | alpha, beta) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceLowerBound_2_lp(y, lower);
    }
    
    void sampleGammaLowerBound_3RR_lp(real[,,] y, real alpha, real beta, real lower)
    {
        real correction_per_value = gamma_lccdf(lower | alpha, beta);
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += gamma_lpdf(y[i, j, k] | alpha, beta) -
                              correction_per_value;
                }
            }
        }
        enforceLowerBound_3_lp(y, lower);
    }
    
    void sampleGammaLowerBound_VRR_lp(vector y, real alpha, real beta, real lower)
    {
        real correction_per_value = gamma_lccdf(lower | alpha, beta);
        target += gamma_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceLowerBound_V_lp(y, lower);
    }
    
    // Sampling with upper bound
    
    void sampleGammaUpperBound_RRR_lp(real y, real alpha, real beta, real upper)
    {
        real correction_per_value = gamma_lcdf(upper | alpha, beta);
        target += gamma_lpdf(y | alpha, beta) -
                  correction_per_value;
        enforceUpperBound_R_lp(y, upper);
    }
    
    void sampleGammaUpperBound_ARR_lp(real[] y, real alpha, real beta, real upper)
    {
        real correction_per_value = gamma_lcdf(upper | alpha, beta);
        target += gamma_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceUpperBound_A_lp(y, upper);
    }
    
    void sampleGammaUpperBound_2RR_lp(real[,] y, real alpha, real beta, real upper)
    {
        real correction_per_value = gamma_lcdf(upper | alpha, beta);
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += gamma_lpdf(y[i] | alpha, beta) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceUpperBound_2_lp(y, upper);
    }
    
    void sampleGammaUpperBound_3RR_lp(real[,,] y, real alpha, real beta, real upper)
    {
        real correction_per_value = gamma_lcdf(upper | alpha, beta);
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += gamma_lpdf(y[i, j, k] | alpha, beta) -
                              correction_per_value;
                }
            }
        }
        enforceUpperBound_3_lp(y, upper);
    }
    
    void sampleGammaUpperBound_VRR_lp(vector y, real alpha, real beta, real upper)
    {
        real correction_per_value = gamma_lcdf(upper | alpha, beta);
        target += gamma_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceUpperBound_V_lp(y, upper);
    }
    
    // Sampling with range (lower and upper) bounds
    
    void sampleGammaRangeBound_RRR_lp(real y, real alpha, real beta, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            gamma_lcdf(upper | alpha, beta),
            gamma_lcdf(lower | alpha, beta));
        target += gamma_lpdf(y | alpha, beta) -
                  correction_per_value;
        enforceRangeBounds_R_lp(y, lower, upper);
    }
    
    void sampleGammaRangeBound_ARR_lp(real[] y, real alpha, real beta, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            gamma_lcdf(upper | alpha, beta),
            gamma_lcdf(lower | alpha, beta));
        target += gamma_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceRangeBounds_A_lp(y, lower, upper);
    }
    
    void sampleGammaRangeBound_2RR_lp(real[,] y, real alpha, real beta, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            gamma_lcdf(upper | alpha, beta),
            gamma_lcdf(lower | alpha, beta));
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += gamma_lpdf(y[i] | alpha, beta) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceRangeBounds_2_lp(y, lower, upper);
    }
    
    void sampleGammaRangeBound_3RR_lp(real[,,] y, real alpha, real beta, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            gamma_lcdf(upper | alpha, beta),
            gamma_lcdf(lower | alpha, beta));
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += gamma_lpdf(y[i, j, k] | alpha, beta) -
                              correction_per_value;
                }
            }
        }
        enforceRangeBounds_3_lp(y, lower, upper);
    }
    
    void sampleGammaRangeBound_VRR_lp(vector y, real alpha, real beta, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            gamma_lcdf(upper | alpha, beta),
            gamma_lcdf(lower | alpha, beta));
        target += gamma_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceRangeBounds_V_lp(y, lower, upper);
    }
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Uniform distribution
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Always constrained with both a lower and an upper bound.
    // Simple; no extra work for the bridge sampler.
    
    // Sampling
    
    void sampleUniform_RRR_lp(real y, real lower, real upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_ARR_lp(real[] y, real lower, real upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_ARA_lp(real[] y, real lower, real[] upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_ARV_lp(real[] y, real lower, vector upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_AAR_lp(real[] y, real[] lower, real upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_AAA_lp(real[] y, real[] lower, real[] upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_AAV_lp(real[] y, real[] lower, vector upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_AVR_lp(real[] y, vector lower, real upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_AVA_lp(real[] y, vector lower, real[] upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_AVV_lp(real[] y, vector lower, vector upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_2RR_lp(real[,] y, real lower, real upper)
    {
        int nrows = size(y);
        for (i in 1:nrows) {
            target += uniform_lpdf(y[i] | lower, upper);
            // ... y[i] is a one-dimensional array
        }
    }
    
    void sampleUniform_3RR_lp(real[,,] y, real lower, real upper)
    {
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += uniform_lpdf(y[i, j, k] | lower, upper);
                }
            }
        }
    }
    
    void sampleUniform_VRR_lp(vector y, real lower, real upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_VRA_lp(vector y, real lower, real[] upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_VRV_lp(vector y, real lower, vector upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_VAR_lp(vector y, real[] lower, real upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_VAA_lp(vector y, real[] lower, real[] upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_VAV_lp(vector y, real[] lower, vector upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_VVR_lp(vector y, vector lower, real upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_VVA_lp(vector y, vector lower, real[] upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_VVV_lp(vector y, vector lower, vector upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Bernoulli distribution
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // y is in {0, 1} and theta is a probability in the range [0, 1].

    void sampleBernoulli_IR_lp(int y, real theta)
    {
        target += bernoulli_lpmf(y | theta);
    }
    void sampleBernoulli_AR_lp(int[] y, real theta)
    {
        target += bernoulli_lpmf(y | theta);
    }
    void sampleBernoulli_AA_lp(int[] y, real[] theta)
    {
        target += bernoulli_lpmf(y | theta);
    }
    void sampleBernoulli_AV_lp(int[] y, vector theta)
    {
        target += bernoulli_lpmf(y | theta);
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Bernoulli logit distribution
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // y is in {0, 1} and alpha is a logit (log odds) in the range [-inf, +inf].

    void sampleBernoulliLogit_IR_lp(int y, real alpha)
    {
        target += bernoulli_logit_lpmf(y | alpha);
    }
    void sampleBernoulliLogit_AR_lp(int[] y, real alpha)
    {
        target += bernoulli_logit_lpmf(y | alpha);
    }
    void sampleBernoulliLogit_AA_lp(int[] y, real[] alpha)
    {
        target += bernoulli_logit_lpmf(y | alpha);
    }
    void sampleBernoulliLogit_AV_lp(int[] y, vector alpha)
    {
        target += bernoulli_logit_lpmf(y | alpha);
    }


    // ------------------------------------------------------------------------
    // LOG PROBABILITY FUNCTIONS FOR BRIDGE SAMPLING WITH NON-CENTERED
    // REPARAMETERIZATION
    // ------------------------------------------------------------------------

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Normal distribution, reparameterized to the unit normal distribution
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Compare Stan (2017) manual p299, but we use a bridgesampling version.

    real reparameterizedNormalBoundary(real boundary, real mu, real sigma)
    {
        // boundary: in real-world N(mu, sigma) space
        // return value: equivalent in the reparameterized N(0, 1) space
        return (boundary - mu) / sigma;
    }
    
    // Plain
    
    real getReparameterizedNormal_RRR_lp(real y_unit_normal, real mu, real sigma)
    {
        real result;
        sampleNormal_RRR_lp(y_unit_normal, 0, 1);
        result = mu + sigma * y_unit_normal;
        return result;
    }
    
    real[] getReparameterizedNormal_ARR_lp(real[] y_unit_normal, real mu, real sigma)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormal_ARA_lp(real[] y_unit_normal, real mu, real[] sigma)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormal_ARV_lp(real[] y_unit_normal, real mu, vector sigma)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormal_AAR_lp(real[] y_unit_normal, real[] mu, real sigma)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormal_AAA_lp(real[] y_unit_normal, real[] mu, real[] sigma)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormal_AAV_lp(real[] y_unit_normal, real[] mu, vector sigma)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormal_AVR_lp(real[] y_unit_normal, vector mu, real sigma)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormal_AVA_lp(real[] y_unit_normal, vector mu, real[] sigma)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormal_AVV_lp(real[] y_unit_normal, vector mu, vector sigma)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[,] getReparameterizedNormal_2RR_lp(real[,] y_unit_normal, real mu, real sigma)
    {
        int dimensions[2] = dims(y_unit_normal);
        real result[dimensions[1], dimensions[2]];
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                sampleNormal_RRR_lp(y_unit_normal[i, j], 0, 1);
                result[i, j] = mu + sigma * y_unit_normal[i, j];
            }
        }
        return result;
    }
    
    real[,,] getReparameterizedNormal_3RR_lp(real[,,] y_unit_normal, real mu, real sigma)
    {
        int dimensions[3] = dims(y_unit_normal);
        real result[dimensions[1], dimensions[2], dimensions[3]];
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    sampleNormal_RRR_lp(y_unit_normal[i, j, k], 0, 1);
                    result[i, j, k] = mu + sigma * y_unit_normal[i, j, k];
                }
            }
        }
        return result;
    }
    
    vector getReparameterizedNormal_VRR_lp(vector y_unit_normal, real mu, real sigma)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormal_VRA_lp(vector y_unit_normal, real mu, real[] sigma)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormal_VRV_lp(vector y_unit_normal, real mu, vector sigma)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormal_VAR_lp(vector y_unit_normal, real[] mu, real sigma)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormal_VAA_lp(vector y_unit_normal, real[] mu, real[] sigma)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormal_VAV_lp(vector y_unit_normal, real[] mu, vector sigma)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormal_VVR_lp(vector y_unit_normal, vector mu, real sigma)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormal_VVA_lp(vector y_unit_normal, vector mu, real[] sigma)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormal_VVV_lp(vector y_unit_normal, vector mu, vector sigma)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    // With lower bound
    
    real getReparameterizedNormalLowerBound_RRR_lp(real y_unit_normal, real mu, real sigma, real lower)
    {
        real result;
        real lower_transformed;
        lower_transformed = (lower - mu) / sigma;
        sampleNormalLowerBound_RRR_lp(y_unit_normal, 0, 1, lower_transformed);
        result = mu + sigma * y_unit_normal;
        return result;
    }
    
    real[] getReparameterizedNormalLowerBound_ARR_lp(real[] y_unit_normal, real mu, real sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma;
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalLowerBound_ARA_lp(real[] y_unit_normal, real mu, real[] sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalLowerBound_ARV_lp(real[] y_unit_normal, real mu, vector sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalLowerBound_AAR_lp(real[] y_unit_normal, real[] mu, real sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma;
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalLowerBound_AAA_lp(real[] y_unit_normal, real[] mu, real[] sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalLowerBound_AAV_lp(real[] y_unit_normal, real[] mu, vector sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalLowerBound_AVR_lp(real[] y_unit_normal, vector mu, real sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma;
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalLowerBound_AVA_lp(real[] y_unit_normal, vector mu, real[] sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalLowerBound_AVV_lp(real[] y_unit_normal, vector mu, vector sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[,] getReparameterizedNormalLowerBound_2RR_lp(real[,] y_unit_normal, real mu, real sigma, real lower)
    {
        int dimensions[2] = dims(y_unit_normal);
        real result[dimensions[1], dimensions[2]];
        real lower_transformed;
        lower_transformed = (lower - mu) / sigma;
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                sampleNormalLowerBound_RRR_lp(y_unit_normal[i, j], 0, 1, lower_transformed);
                result[i, j] = mu + sigma * y_unit_normal[i, j];
            }
        }
        return result;
    }
    
    real[,,] getReparameterizedNormalLowerBound_3RR_lp(real[,,] y_unit_normal, real mu, real sigma, real lower)
    {
        int dimensions[3] = dims(y_unit_normal);
        real result[dimensions[1], dimensions[2], dimensions[3]];
        real lower_transformed;
        lower_transformed = (lower - mu) / sigma;
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    sampleNormalLowerBound_RRR_lp(y_unit_normal[i, j, k], 0, 1, lower_transformed);
                    result[i, j, k] = mu + sigma * y_unit_normal[i, j, k];
                }
            }
        }
        return result;
    }
    
    vector getReparameterizedNormalLowerBound_VRR_lp(vector y_unit_normal, real mu, real sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma;
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalLowerBound_VRA_lp(vector y_unit_normal, real mu, real[] sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalLowerBound_VRV_lp(vector y_unit_normal, real mu, vector sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalLowerBound_VAR_lp(vector y_unit_normal, real[] mu, real sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma;
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalLowerBound_VAA_lp(vector y_unit_normal, real[] mu, real[] sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalLowerBound_VAV_lp(vector y_unit_normal, real[] mu, vector sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalLowerBound_VVR_lp(vector y_unit_normal, vector mu, real sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma;
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalLowerBound_VVA_lp(vector y_unit_normal, vector mu, real[] sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalLowerBound_VVV_lp(vector y_unit_normal, vector mu, vector sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    // With upper bound
    
    real getReparameterizedNormalUpperBound_RRR_lp(real y_unit_normal, real mu, real sigma, real upper)
    {
        real result;
        real upper_transformed;
        upper_transformed = (upper - mu) / sigma;
        sampleNormalUpperBound_RRR_lp(y_unit_normal, 0, 1, upper_transformed);
        result = mu + sigma * y_unit_normal;
        return result;
    }
    
    real[] getReparameterizedNormalUpperBound_ARR_lp(real[] y_unit_normal, real mu, real sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real upper_transformed;
        for (i in 1:length) {
            upper_transformed = (upper - mu) / sigma;
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalUpperBound_ARA_lp(real[] y_unit_normal, real mu, real[] sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalUpperBound_ARV_lp(real[] y_unit_normal, real mu, vector sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalUpperBound_AAR_lp(real[] y_unit_normal, real[] mu, real sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma;
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalUpperBound_AAA_lp(real[] y_unit_normal, real[] mu, real[] sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalUpperBound_AAV_lp(real[] y_unit_normal, real[] mu, vector sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalUpperBound_AVR_lp(real[] y_unit_normal, vector mu, real sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma;
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalUpperBound_AVA_lp(real[] y_unit_normal, vector mu, real[] sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalUpperBound_AVV_lp(real[] y_unit_normal, vector mu, vector sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[,] getReparameterizedNormalUpperBound_2RR_lp(real[,] y_unit_normal, real mu, real sigma, real upper)
    {
        int dimensions[2] = dims(y_unit_normal);
        real result[dimensions[1], dimensions[2]];
        real upper_transformed;
        upper_transformed = (upper - mu) / sigma;
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                sampleNormalUpperBound_RRR_lp(y_unit_normal[i, j], 0, 1, upper_transformed);
                result[i, j] = mu + sigma * y_unit_normal[i, j];
            }
        }
        return result;
    }
    
    real[,,] getReparameterizedNormalUpperBound_3RR_lp(real[,,] y_unit_normal, real mu, real sigma, real upper)
    {
        int dimensions[3] = dims(y_unit_normal);
        real result[dimensions[1], dimensions[2], dimensions[3]];
        real upper_transformed;
        upper_transformed = (upper - mu) / sigma;
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    sampleNormalUpperBound_RRR_lp(y_unit_normal[i, j, k], 0, 1, upper_transformed);
                    result[i, j, k] = mu + sigma * y_unit_normal[i, j, k];
                }
            }
        }
        return result;
    }
    
    vector getReparameterizedNormalUpperBound_VRR_lp(vector y_unit_normal, real mu, real sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real upper_transformed;
        for (i in 1:length) {
            upper_transformed = (upper - mu) / sigma;
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalUpperBound_VRA_lp(vector y_unit_normal, real mu, real[] sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalUpperBound_VRV_lp(vector y_unit_normal, real mu, vector sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalUpperBound_VAR_lp(vector y_unit_normal, real[] mu, real sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma;
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalUpperBound_VAA_lp(vector y_unit_normal, real[] mu, real[] sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalUpperBound_VAV_lp(vector y_unit_normal, real[] mu, vector sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalUpperBound_VVR_lp(vector y_unit_normal, vector mu, real sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma;
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalUpperBound_VVA_lp(vector y_unit_normal, vector mu, real[] sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalUpperBound_VVV_lp(vector y_unit_normal, vector mu, vector sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    // With range (lower and upper) bounds
    
    real getReparameterizedNormalRangeBound_RRR_lp(real y_unit_normal, real mu, real sigma, real lower, real upper)
    {
        real result;
        real lower_transformed;
        real upper_transformed;
        lower_transformed = (lower - mu) / sigma;
        upper_transformed = (upper - mu) / sigma;
        sampleNormalRangeBound_RRR_lp(y_unit_normal, 0, 1, lower_transformed, upper_transformed);
        result = mu + sigma * y_unit_normal;
        return result;
    }
    
    real[] getReparameterizedNormalRangeBound_ARR_lp(real[] y_unit_normal, real mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma;
            upper_transformed = (upper - mu) / sigma;
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalRangeBound_ARA_lp(real[] y_unit_normal, real mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma[i];
            upper_transformed = (upper - mu) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalRangeBound_ARV_lp(real[] y_unit_normal, real mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma[i];
            upper_transformed = (upper - mu) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalRangeBound_AAR_lp(real[] y_unit_normal, real[] mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma;
            upper_transformed = (upper - mu[i]) / sigma;
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalRangeBound_AAA_lp(real[] y_unit_normal, real[] mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalRangeBound_AAV_lp(real[] y_unit_normal, real[] mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalRangeBound_AVR_lp(real[] y_unit_normal, vector mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma;
            upper_transformed = (upper - mu[i]) / sigma;
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalRangeBound_AVA_lp(real[] y_unit_normal, vector mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalRangeBound_AVV_lp(real[] y_unit_normal, vector mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[,] getReparameterizedNormalRangeBound_2RR_lp(real[,] y_unit_normal, real mu, real sigma, real lower, real upper)
    {
        int dimensions[2] = dims(y_unit_normal);
        real result[dimensions[1], dimensions[2]];
        real lower_transformed;
        real upper_transformed;
        lower_transformed = (lower - mu) / sigma;
        upper_transformed = (upper - mu) / sigma;
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                sampleNormalRangeBound_RRR_lp(y_unit_normal[i, j], 0, 1, lower_transformed, upper_transformed);
                result[i, j] = mu + sigma * y_unit_normal[i, j];
            }
        }
        return result;
    }
    
    real[,,] getReparameterizedNormalRangeBound_3RR_lp(real[,,] y_unit_normal, real mu, real sigma, real lower, real upper)
    {
        int dimensions[3] = dims(y_unit_normal);
        real result[dimensions[1], dimensions[2], dimensions[3]];
        real lower_transformed;
        real upper_transformed;
        lower_transformed = (lower - mu) / sigma;
        upper_transformed = (upper - mu) / sigma;
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    sampleNormalRangeBound_RRR_lp(y_unit_normal[i, j, k], 0, 1, lower_transformed, upper_transformed);
                    result[i, j, k] = mu + sigma * y_unit_normal[i, j, k];
                }
            }
        }
        return result;
    }
    
    vector getReparameterizedNormalRangeBound_VRR_lp(vector y_unit_normal, real mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma;
            upper_transformed = (upper - mu) / sigma;
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalRangeBound_VRA_lp(vector y_unit_normal, real mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma[i];
            upper_transformed = (upper - mu) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalRangeBound_VRV_lp(vector y_unit_normal, real mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma[i];
            upper_transformed = (upper - mu) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalRangeBound_VAR_lp(vector y_unit_normal, real[] mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma;
            upper_transformed = (upper - mu[i]) / sigma;
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalRangeBound_VAA_lp(vector y_unit_normal, real[] mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalRangeBound_VAV_lp(vector y_unit_normal, real[] mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalRangeBound_VVR_lp(vector y_unit_normal, vector mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma;
            upper_transformed = (upper - mu[i]) / sigma;
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalRangeBound_VVA_lp(vector y_unit_normal, vector mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalRangeBound_VVV_lp(vector y_unit_normal, vector mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Cauchy distribution, reparameterized to the uniform distribution
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    /*
    See p339 of the Stan (2017) manual.
    The transformation is

        y_cauchy(mu, sigma) = mu + sigma * y_uniform(-pi/2, pi/2)

    so the boundary transformation is the reverse, namely

        uniform_boundary = arctan((boundary - mu) / sigma)

    Note that
        arctan(-infinity) is -pi/2; arctan(0) is 0; arctan(infinity) is pi/2
        ... so for lower == 0, lower_transformed == 0

    We can do the range constraints like this:
         real<lower=-pi()/2, upper=pi()/2> y_uniform;  // Cauchy
         real<lower=0, upper=pi()/2> y_uniform;  // positive half-Cauchy
    and the sampling statement would be unnecessary, but we're going to
    to the sampling using "target +=" so that bridgesampling works.

    You might think that because of that, the range constraint is unnecessary,
    but it IS STILL NECESSARY or Stan will explore invalid ranges.

    */

    real reparameterizedCauchyBoundary(real boundary, real mu, real sigma)
    {
        // boundary: in real-world Cauchy(mu, sigma) space
        // return value: equivalent in the reparameterized uniform [-pi/2, +pi/2] space
        return atan((boundary - mu) / sigma);
    }
    
    // Plain
    
    real getReparameterizedCauchy_RRR_lp(real y_uniform, real mu, real sigma)
    {
        real result;
        sampleUniform_RRR_lp(y_uniform, -pi()/2, pi()/2);
        result = mu + sigma * tan(y_uniform);
        return result;
    }
    
    real[] getReparameterizedCauchy_ARR_lp(real[] y_uniform, real mu, real sigma)
    {
        int length = num_elements(y_uniform);
        real result[length];
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchy_ARA_lp(real[] y_uniform, real mu, real[] sigma)
    {
        int length = num_elements(y_uniform);
        real result[length];
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchy_ARV_lp(real[] y_uniform, real mu, vector sigma)
    {
        int length = num_elements(y_uniform);
        real result[length];
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchy_AAR_lp(real[] y_uniform, real[] mu, real sigma)
    {
        int length = num_elements(y_uniform);
        real result[length];
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchy_AAA_lp(real[] y_uniform, real[] mu, real[] sigma)
    {
        int length = num_elements(y_uniform);
        real result[length];
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchy_AAV_lp(real[] y_uniform, real[] mu, vector sigma)
    {
        int length = num_elements(y_uniform);
        real result[length];
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchy_AVR_lp(real[] y_uniform, vector mu, real sigma)
    {
        int length = num_elements(y_uniform);
        real result[length];
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchy_AVA_lp(real[] y_uniform, vector mu, real[] sigma)
    {
        int length = num_elements(y_uniform);
        real result[length];
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchy_AVV_lp(real[] y_uniform, vector mu, vector sigma)
    {
        int length = num_elements(y_uniform);
        real result[length];
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[,] getReparameterizedCauchy_2RR_lp(real[,] y_uniform, real mu, real sigma)
    {
        int dimensions[2] = dims(y_uniform);
        real result[dimensions[1], dimensions[2]];
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                sampleUniform_RRR_lp(y_uniform[i, j], -pi()/2, pi()/2);
                result[i, j] = mu + sigma * tan(y_uniform[i, j]);
            }
        }
        return result;
    }
    
    real[,,] getReparameterizedCauchy_3RR_lp(real[,,] y_uniform, real mu, real sigma)
    {
        int dimensions[3] = dims(y_uniform);
        real result[dimensions[1], dimensions[2], dimensions[3]];
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    sampleUniform_RRR_lp(y_uniform[i, j, k], -pi()/2, pi()/2);
                    result[i, j, k] = mu + sigma * tan(y_uniform[i, j, k]);
                }
            }
        }
        return result;
    }
    
    vector getReparameterizedCauchy_VRR_lp(vector y_uniform, real mu, real sigma)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchy_VRA_lp(vector y_uniform, real mu, real[] sigma)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchy_VRV_lp(vector y_uniform, real mu, vector sigma)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchy_VAR_lp(vector y_uniform, real[] mu, real sigma)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchy_VAA_lp(vector y_uniform, real[] mu, real[] sigma)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchy_VAV_lp(vector y_uniform, real[] mu, vector sigma)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchy_VVR_lp(vector y_uniform, vector mu, real sigma)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchy_VVA_lp(vector y_uniform, vector mu, real[] sigma)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchy_VVV_lp(vector y_uniform, vector mu, vector sigma)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    // With lower bound
    
    real getReparameterizedCauchyLowerBound_RRR_lp(real y_uniform, real mu, real sigma, real lower)
    {
        real result;
        real lower_transformed;
        lower_transformed = atan((lower - mu) / sigma);
        sampleUniform_RRR_lp(y_uniform, lower_transformed, pi()/2);
        result = mu + sigma * tan(y_uniform);
        return result;
    }
    
    real[] getReparameterizedCauchyLowerBound_ARR_lp(real[] y_uniform, real mu, real sigma, real lower)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyLowerBound_ARA_lp(real[] y_uniform, real mu, real[] sigma, real lower)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyLowerBound_ARV_lp(real[] y_uniform, real mu, vector sigma, real lower)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyLowerBound_AAR_lp(real[] y_uniform, real[] mu, real sigma, real lower)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyLowerBound_AAA_lp(real[] y_uniform, real[] mu, real[] sigma, real lower)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyLowerBound_AAV_lp(real[] y_uniform, real[] mu, vector sigma, real lower)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyLowerBound_AVR_lp(real[] y_uniform, vector mu, real sigma, real lower)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyLowerBound_AVA_lp(real[] y_uniform, vector mu, real[] sigma, real lower)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyLowerBound_AVV_lp(real[] y_uniform, vector mu, vector sigma, real lower)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[,] getReparameterizedCauchyLowerBound_2RR_lp(real[,] y_uniform, real mu, real sigma, real lower)
    {
        int dimensions[2] = dims(y_uniform);
        real result[dimensions[1], dimensions[2]];
        real lower_transformed;
        lower_transformed = atan((lower - mu) / sigma);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                sampleUniform_RRR_lp(y_uniform[i, j], lower_transformed, pi()/2);
                result[i, j] = mu + sigma * tan(y_uniform[i, j]);
            }
        }
        return result;
    }
    
    real[,,] getReparameterizedCauchyLowerBound_3RR_lp(real[,,] y_uniform, real mu, real sigma, real lower)
    {
        int dimensions[3] = dims(y_uniform);
        real result[dimensions[1], dimensions[2], dimensions[3]];
        real lower_transformed;
        lower_transformed = atan((lower - mu) / sigma);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    sampleUniform_RRR_lp(y_uniform[i, j, k], lower_transformed, pi()/2);
                    result[i, j, k] = mu + sigma * tan(y_uniform[i, j, k]);
                }
            }
        }
        return result;
    }
    
    vector getReparameterizedCauchyLowerBound_VRR_lp(vector y_uniform, real mu, real sigma, real lower)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyLowerBound_VRA_lp(vector y_uniform, real mu, real[] sigma, real lower)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyLowerBound_VRV_lp(vector y_uniform, real mu, vector sigma, real lower)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyLowerBound_VAR_lp(vector y_uniform, real[] mu, real sigma, real lower)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyLowerBound_VAA_lp(vector y_uniform, real[] mu, real[] sigma, real lower)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyLowerBound_VAV_lp(vector y_uniform, real[] mu, vector sigma, real lower)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyLowerBound_VVR_lp(vector y_uniform, vector mu, real sigma, real lower)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyLowerBound_VVA_lp(vector y_uniform, vector mu, real[] sigma, real lower)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyLowerBound_VVV_lp(vector y_uniform, vector mu, vector sigma, real lower)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    // With upper bound
    
    real getReparameterizedCauchyUpperBound_RRR_lp(real y_uniform, real mu, real sigma, real upper)
    {
        real result;
        real upper_transformed;
        upper_transformed = atan((upper - mu) / sigma);
        sampleUniform_RRR_lp(y_uniform, -pi()/2, upper_transformed);
        result = mu + sigma * tan(y_uniform);
        return result;
    }
    
    real[] getReparameterizedCauchyUpperBound_ARR_lp(real[] y_uniform, real mu, real sigma, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real upper_transformed;
        for (i in 1:length) {
            upper_transformed = atan((upper - mu) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyUpperBound_ARA_lp(real[] y_uniform, real mu, real[] sigma, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyUpperBound_ARV_lp(real[] y_uniform, real mu, vector sigma, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyUpperBound_AAR_lp(real[] y_uniform, real[] mu, real sigma, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyUpperBound_AAA_lp(real[] y_uniform, real[] mu, real[] sigma, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyUpperBound_AAV_lp(real[] y_uniform, real[] mu, vector sigma, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyUpperBound_AVR_lp(real[] y_uniform, vector mu, real sigma, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyUpperBound_AVA_lp(real[] y_uniform, vector mu, real[] sigma, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyUpperBound_AVV_lp(real[] y_uniform, vector mu, vector sigma, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[,] getReparameterizedCauchyUpperBound_2RR_lp(real[,] y_uniform, real mu, real sigma, real upper)
    {
        int dimensions[2] = dims(y_uniform);
        real result[dimensions[1], dimensions[2]];
        real upper_transformed;
        upper_transformed = atan((upper - mu) / sigma);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                sampleUniform_RRR_lp(y_uniform[i, j], -pi()/2, upper_transformed);
                result[i, j] = mu + sigma * tan(y_uniform[i, j]);
            }
        }
        return result;
    }
    
    real[,,] getReparameterizedCauchyUpperBound_3RR_lp(real[,,] y_uniform, real mu, real sigma, real upper)
    {
        int dimensions[3] = dims(y_uniform);
        real result[dimensions[1], dimensions[2], dimensions[3]];
        real upper_transformed;
        upper_transformed = atan((upper - mu) / sigma);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    sampleUniform_RRR_lp(y_uniform[i, j, k], -pi()/2, upper_transformed);
                    result[i, j, k] = mu + sigma * tan(y_uniform[i, j, k]);
                }
            }
        }
        return result;
    }
    
    vector getReparameterizedCauchyUpperBound_VRR_lp(vector y_uniform, real mu, real sigma, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real upper_transformed;
        for (i in 1:length) {
            upper_transformed = atan((upper - mu) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyUpperBound_VRA_lp(vector y_uniform, real mu, real[] sigma, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyUpperBound_VRV_lp(vector y_uniform, real mu, vector sigma, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyUpperBound_VAR_lp(vector y_uniform, real[] mu, real sigma, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyUpperBound_VAA_lp(vector y_uniform, real[] mu, real[] sigma, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyUpperBound_VAV_lp(vector y_uniform, real[] mu, vector sigma, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyUpperBound_VVR_lp(vector y_uniform, vector mu, real sigma, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyUpperBound_VVA_lp(vector y_uniform, vector mu, real[] sigma, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyUpperBound_VVV_lp(vector y_uniform, vector mu, vector sigma, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    // With range (lower and upper) bounds
    
    real getReparameterizedCauchyRangeBound_RRR_lp(real y_uniform, real mu, real sigma, real lower, real upper)
    {
        real result;
        real lower_transformed;
        real upper_transformed;
        lower_transformed = atan((lower - mu) / sigma);
        upper_transformed = atan((upper - mu) / sigma);
        sampleUniform_RRR_lp(y_uniform, lower_transformed, upper_transformed);
        result = mu + sigma * tan(y_uniform);
        return result;
    }
    
    real[] getReparameterizedCauchyRangeBound_ARR_lp(real[] y_uniform, real mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma);
            upper_transformed = atan((upper - mu) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyRangeBound_ARA_lp(real[] y_uniform, real mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma[i]);
            upper_transformed = atan((upper - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyRangeBound_ARV_lp(real[] y_uniform, real mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma[i]);
            upper_transformed = atan((upper - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyRangeBound_AAR_lp(real[] y_uniform, real[] mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma);
            upper_transformed = atan((upper - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyRangeBound_AAA_lp(real[] y_uniform, real[] mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyRangeBound_AAV_lp(real[] y_uniform, real[] mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyRangeBound_AVR_lp(real[] y_uniform, vector mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma);
            upper_transformed = atan((upper - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyRangeBound_AVA_lp(real[] y_uniform, vector mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyRangeBound_AVV_lp(real[] y_uniform, vector mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[,] getReparameterizedCauchyRangeBound_2RR_lp(real[,] y_uniform, real mu, real sigma, real lower, real upper)
    {
        int dimensions[2] = dims(y_uniform);
        real result[dimensions[1], dimensions[2]];
        real lower_transformed;
        real upper_transformed;
        lower_transformed = atan((lower - mu) / sigma);
        upper_transformed = atan((upper - mu) / sigma);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                sampleUniform_RRR_lp(y_uniform[i, j], lower_transformed, upper_transformed);
                result[i, j] = mu + sigma * tan(y_uniform[i, j]);
            }
        }
        return result;
    }
    
    real[,,] getReparameterizedCauchyRangeBound_3RR_lp(real[,,] y_uniform, real mu, real sigma, real lower, real upper)
    {
        int dimensions[3] = dims(y_uniform);
        real result[dimensions[1], dimensions[2], dimensions[3]];
        real lower_transformed;
        real upper_transformed;
        lower_transformed = atan((lower - mu) / sigma);
        upper_transformed = atan((upper - mu) / sigma);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    sampleUniform_RRR_lp(y_uniform[i, j, k], lower_transformed, upper_transformed);
                    result[i, j, k] = mu + sigma * tan(y_uniform[i, j, k]);
                }
            }
        }
        return result;
    }
    
    vector getReparameterizedCauchyRangeBound_VRR_lp(vector y_uniform, real mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma);
            upper_transformed = atan((upper - mu) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyRangeBound_VRA_lp(vector y_uniform, real mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma[i]);
            upper_transformed = atan((upper - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyRangeBound_VRV_lp(vector y_uniform, real mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma[i]);
            upper_transformed = atan((upper - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyRangeBound_VAR_lp(vector y_uniform, real[] mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma);
            upper_transformed = atan((upper - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyRangeBound_VAA_lp(vector y_uniform, real[] mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyRangeBound_VAV_lp(vector y_uniform, real[] mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyRangeBound_VVR_lp(vector y_uniform, vector mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma);
            upper_transformed = atan((upper - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyRangeBound_VVA_lp(vector y_uniform, vector mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyRangeBound_VVV_lp(vector y_uniform, vector mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    // ------------------------------------------------------------------------
    // ANOVA-type designs: DEPRECATED APPROACH
    // ------------------------------------------------------------------------
    // ... rather than coding intercept + main effects + interactions (etc.),
    // as here, it's probably best to code individual cells. That makes
    // distributions more sensible (and predictable/easily calculable).

    int interactionIndex2Way(int first_index, int first_max,
                             int second_index, int second_max)
    {
        /*
            Because Stan doesn't support sampling into matrix, we need to
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            convert matrix-like concepts to vectors. Specifically, it doesn't
            support either
                matrix[A, B] m;
                m ~ normal(0, 0.5);  // error: "no matches for matrix ~ normal(int, real)"
            or
                real a[A, B];
                a ~ normal(0, 0.5);  // error: "no matches for real[,] ~ normal(int, real)"

            And note that a vectorized sampling statement is strongly preferred
            (for performance reasons) over iterating through a matrix:
                https://groups.google.com/forum/#!topic/stan-users/4gv3fNCqSNk
                    "Do not loop over sampling statements when a vectorized
                    sampling statement is possible"

            So we use a vector of size A*B, and this index lookup function.
            Parameters:
            - first_index is from 1 to first_max
            - second_index is from 1 to second_max
            - We want a consecutive index from 1 to (first_max * second_max)

            In the output, the FIRST will cycle LEAST rapidly, and the
            LAST will cycle MOST rapidly.
        */
        return (
            (first_index - 1) * first_max +     // slow cycling
            second_index                        // fast cycling
        );
    }

    vector setLastForZeroSum(vector params)
    {
        /*
            Makes a vector of parameters sum to zero, by setting the last
            element to the negative sum of the others.
            Used for ANOVA-style effects; e.g. if you have a grand mean, you
            might specify the effects of a three-level factor A as A1, A2, A3;
            then A1 + A2 + A3 must be zero, so A1 and A2 are free parameters
            that are drawn from an appropriate distribution, and then A3 is
            fully constrainted to be -(A1 + A2).

            Because we can't modify the input parameters, we make a new copy.

            Returns a vector of the SAME LENGTH as the original.
            (The last element of the incoming vector is ignored.)
        */
        int length = num_elements(params);
        vector[length] newparams;
        real total = 0.0;
        for (i in 1:length - 1) {
            real value = params[i];
            newparams[i] = value;
            total = total + value;
        }
        newparams[length] = -total;
        return newparams;
    }

    vector appendElementForZeroSum(vector params)
    {
        /*
            As for setLastForZeroSum(), but uses all the information in the
            incoming vector, and returns a vector that's one element longer.
        */
        int initial_length = num_elements(params);
        int new_length = initial_length + 1;
        vector[new_length] newparams;
        real total = 0.0;
        for (i in 1:initial_length) {
            real value = params[i];
            newparams[i] = value;
            total = total + value;
        }
        newparams[new_length] = -total;
        return newparams;
    }
