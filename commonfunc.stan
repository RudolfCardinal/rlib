
    // DO NOT EDIT THIS FILE DIRECTLY. It is created by make_commonfunc_stan.py.

    // ========================================================================
    // Common functions
    // ========================================================================
    /*
        Reminders -- Stan's flavour of C++:
        -----------------------------------------------------------------------

        - Disappointingly, you can't modify arguments to Stan user-defined
          functions. (No pass-by-reference.)

        - You can't have templating of user-defined functions, i.e. not this:

            template<T> T somefunc(T x);

        - Two functions with the same name can't even have different
          signatures. So not this:

            real somefunc(real x);
            vector somefunc(vector x);

        - No default values for function parameters. So not this:

            real somefunc(x, y = 0);

        - We can't use a leading "_" prefix on function names (gives a Stan
          syntax error).

        - The addition-assignment (+=) operator generally doesn't work (it
          appears to be reserved for the one variable "target += ...").
          Similarly for all others you might expect.

          - Aha! By Stan 2.19, this has changed. Can use "x += 1"
            (p19 of Stan 2.19 Reference Manual).

        - The ternary (conditional, ?:) operator *is* supported, e.g.:

            x = a ? b : c;

          Simpler C++ statements (e.g. with the ternary operator) translate
          to fewer C++ statements.

        Reminders -- Stan, other:
        -----------------------------------------------------------------------

        - OUTDATED: previously, size() didn't work on a plain "vector" and one
          should have used num_elements(). This is fixed as of Stan ~2.24: see
          https://discourse.mc-stan.org/t/option-to-keep-constant-terms-in-log-probability-via-standard-sampling-syntax/20278/2.
          But remember that size() is "top-level" size (e.g. the first
          dimension of an array), whereas num_elements() counts all elements.

        - Array/vector indexing is 1-based.

        - Can't define constants in a functions{} block.

    */

    // ------------------------------------------------------------------------
    // Softmax
    // ------------------------------------------------------------------------

    real softmaxNth(vector softmax_inputs, int index)
    {
        /*
            Returns the nth value (at "index") of the softmax of the inputs.
            Assumes an inverse temperature of 1.

        NOTES:
            A softmax function takes several inputs and normalizes them so
            that:
                - the outputs are in the same relative order as the inputs
                - the outputs sum to 1.

            For softmax: see my miscstat.R; the important points for
            optimization are (1) that softmax is invariant to the addition/
            subtraction of a constant, and subtracting the mean makes the
            numbers less likely to fall over computationally; (2) we only
            need the final part of the computation for a single number
            (preference for the right), so we don't have to waste time
            vector-calculating the preference for the left as well [that is:
            we don't have to calculate s_exp_products / sum(s_exp_products)].

            The constant can be the mean, or the max; Stan uses the max, which
            is probably a little more efficient.

            Since Stan 2.0.0, the alternative is to use softmax(); see
            https://github.com/stan-dev/math/blob/develop/stan/math/prim/mat/fun/softmax.hpp
            The exact syntactic equivalence is:

                real result = softmaxNth(inputs, index);
                real result = softmax(inputs)[index];

            Stan's version is in stan/math/prim/mat/fun/softmax.hpp; it uses
            Eigen.

            This "homebrew" version is faster than using Stan's built-in
            softmax(), surprisingly. See
            tests/profile_stan_softmax/profile_softmax.stan.
        */

        int length = num_elements(softmax_inputs);
        real constant = max(softmax_inputs);
        vector[length] s_exp_products = exp(softmax_inputs - constant);
        return s_exp_products[index] / sum(s_exp_products);

        // The alternative (slower, surprisingly) would be:
        // return softmax(softmax_inputs)[index];  // Use Stan's built-in version.
    }

    real softmaxNthInvTemp(vector softmax_inputs, real inverse_temp, int index)
    {
        /*
            Version of softmaxNth allowing you to specify the inverse temp.

            The direct Stan equivalent is:

                real result = softmaxNthInvTemp(inputs, invtemp, index);
                real result = softmax(inputs * invtemp)[index];
        */

        return softmaxNth(softmax_inputs * inverse_temp, index);
        // return softmax(softmax_inputs * inverse_temp)[index];
    }

    real logitSoftmaxNth(vector inputs, int index)
    {
        // Returns logit(softmax(inputs))[index].

        // METHOD 1 (fewer calculations involved and empirically faster):
        real log_p = inputs[index] - log_sum_exp(inputs);

        // METHOD 2 (empirically slower):
        // real log_p = log_softmax(inputs)[index];

        // EITHER WAY:
        // Conceptually:
        // (a) log_1mp = log(1 - p)
        //             = log(1 - exp(log_p))
        //             = log1m_exp(log_p)
        // (b) logit   = log(p) - log(1 - p)
        //             = log_p - log_1mp
        // It is very slightly faster (from profiling) to do this in a single
        // step:

        return log_p - log1m_exp(log_p);
    }

    // ------------------------------------------------------------------------
    // Logistic function
    // ------------------------------------------------------------------------

    // For the logit function, use Stan's built-in logit().

    real logistic(real x, real x0, real k, real L)
    {
        // Returns x transformed through a logistic function.
        // Notation as per https://en.wikipedia.org/wiki/Logistic_function
        // x0: centre
        // k: steepness
        // L: maximum (usually 1)

        return L / (1 + exp(-k * (x - x0)));

        // If you were to transform x so as to be a logit giving the same
        // result via the standard logistic function, 1 / (1 + exp(-x)), for
        // L = 1, you want this logit:
        //      k * (x - x0)
    }

    // For the standard logistic (with x0 = 0, k = 1, L = 1), use Stan's
    // inv_logit(). 

    // ------------------------------------------------------------------------
    // Boundaries (min, max)
    // ------------------------------------------------------------------------

    real bound(real x, real min_value, real max_value)
    {
        // Returns x with minimum/maximum boundaries applied.
        // We would simply do this:
        //     return max(min_value, min(x, max_value));
        // ... but Stan doesn't have max(real, real) or min(real, real) 
        // functions.

        return x < min_value ? min_value : (x > max_value ? max_value : x);
    }

    real boundLower(real x, real min_value)
    {
        // a.k.a. max()

        return x < min_value ? min_value : x;
    }

    real boundUpper(real x, real max_value)
    {
        // a.k.a. min()

        return x > max_value ? max_value : x;
    }

    // ------------------------------------------------------------------------
    // Basic data manipulation
    // ------------------------------------------------------------------------

    vector vector_from_real_array_row(real[,] x, int row)
    {
        // Given an array
        //      real x[nrows, ncols];
        // you can slice the array with
        //      real a[ncols] = x[row];
        // but not with
        //      vector[ncols] y = x[row];
        // so this function does that.

        int ncols = dims(x)[2];
        vector[ncols] v;
        for (i in 1:ncols) {
            v[i] = x[row, i];
        }
        return v;
    }

    vector vector_from_int_array_row(int[,] x, int row)
    {
        // As above, but for an int array.

        int ncols = dims(x)[2];
        vector[ncols] v;
        for (i in 1:ncols) {
            v[i] = x[row, i];
        }
        return v;
    }

    vector except_V_V(vector v, int except)
    {
        // Returns a vector that is the original without the element at index
        // "except".

        int n = num_elements(v);
        vector[n - 1] result;
        int r = 1;  // indexes result
        for (i in 1:n) {
            if (i == except) {
                continue;
            }
            result[r] = v[i];
            r += 1;
        }
        return result;
    }

    int except_I_I(int x, int except)
    {
        // The argument is an index to a vector v; the result is the equivalent
        // index to the vector returned by except_V_V(v, except).

        if (x < 1) {
            reject("Argument x is a Stan index so must be >= 1");
        }
        if (except == x) {
            reject("Cannot remove 'except' where except == x");
        }
        if (except < 1 || except > x) {
            return x;
        }
        return x - 1;
    }

    // ------------------------------------------------------------------------
    // Simple functions: matrix calculations
    // ------------------------------------------------------------------------
    // Note that Stan only provides the following versions of dot_product():
    //      dot_product(vector, vector)
    //      dot_product(row vector, row vector)
    //      dot_product(vector, row vector)
    //      dot_product(row vector, vector)
    //      dot_product(real[], real[])

    vector dot_product_MV_V(matrix x, vector y)
    {
        // Dot product between a matrix (2 dimensions) and a vector (1
        // dimension):
        //
        //      (p, q) matrix ⋅ (q, 1) vector = (p, 1) vector
        //
        // For example:
        //
        //              [a, b]   [g]      [ag + bh]
        //      x ⋅ y = [c, d] ⋅ [h]    = [cg + dh]
        //              [e, f]            [eg + fh]
        //
        //              (3, 2) ⋅ (2, 1) = (3, 1)

        int x_dimensions[2] = dims(x);
        int p = x_dimensions[1];
        int q = x_dimensions[2];
        vector[p] z;
        real cell;

        if (q != num_elements(y)) {
            reject("Incompatible arguments");
        }
        for (i in 1:p) {  // rows of x
            cell = 0.0;
            for (j in 1:q) {  // columns of x
                cell += x[i, j] * y[j];
            }
            z[i] = cell;
        }
        return z;
    }

    vector dot_product_2A_V(real[,] x, real[] y)
    {
        // As dot_product_MV_V, but for array inputs.

        int x_dimensions[2] = dims(x);
        int p = x_dimensions[1];
        int q = x_dimensions[2];
        vector[p] z;
        real cell;

        if (q != num_elements(y)) {
            reject("Incompatible arguments");
        }
        for (i in 1:p) {  // rows of x
            cell = 0.0;
            for (j in 1:q) {  // columns of x
                cell += x[i, j] * y[j];
            }
            z[i] = cell;
        }
        return z;
    }

    vector dot_product_VM_V(vector x, matrix y)
    {
        // Dot product between a vector (1 dimension) and a matrix (2
        // dimensions):
        //
        //      (1, p) vector ⋅ (p, q) matrix = (1, q) vector
        //
        // For example:
        //
        //                       [a, c, e]
        //      x ⋅ y = [g, h] ⋅ [b, d, f] = [ag + bh, cg + dh, eg + fh]
        //                                 = y' ⋅ x'
        //
        //              (1, 2) ⋅ (2, 3)    = (1, 3) 

        int y_dimensions[2] = dims(y);
        int p = y_dimensions[1];
        int q = y_dimensions[2];
        vector[q] z;
        real cell;

        if (p != num_elements(x)) {
            reject("Incompatible arguments");
        }
        for (j in 1:q) {  // columns of y
            cell = 0.0;
            for (i in 1:p) {  // rows of y
                cell += x[j] * y[i, j];
            }
            z[j] = cell;
        }
        return z;
    }

    vector dot_product_A2_V(real[] x, real[,] y)
    {
        // As dot_product_VM_V(), but for array inputs.

        int y_dimensions[2] = dims(y);
        int p = y_dimensions[1];
        int q = y_dimensions[2];
        vector[q] z;
        real cell;

        if (p != num_elements(x)) {
            reject("Incompatible arguments");
        }
        for (j in 1:q) {  // columns of y
            cell = 0.0;
            for (i in 1:p) {  // rows of y
                cell += x[j] * y[i, j];
            }
            z[j] = cell;
        }
        return z;
    }

    real dot_product_AA_R(real[] x, real[] y)
    {
        // Dot product of two arrays.

        int n = num_elements(x);
        real z = 0.0;
        if (n != num_elements(y)) {
            reject("Incompatible arguments");
        }
        for (i in 1:n) {
            z += x[i] * y[i];
        }
        return z;
    }

    real dot_product_iAV_R(int[] x, vector y)
    {
        int n = num_elements(x);
        real z = 0.0;
        if (n != num_elements(y)) {
            reject("Incompatible arguments");
        }
        for (i in 1:n) {
            z += x[i] * y[i];
        }
        return z;
    }

    matrix tensordot_A3_M(real[] x, real[,,] y)
    {
        // Equivalent to Numpy's tensordot(x, y, axes=1), for:
        //
        //      (1, p) ⋅ (p, q, r) = (q, r)
        //
        // For example:
        //
        //      [a, b] ⋅ [ [c, d, e, f]       = [ac + bc', ad + bd', ...]
        //                 [g, h, i, j]         [ag + bg', ag + bg', ...]
        //                 [k, l, m, n],        [ak + bk', ak + bk', ...]
        //
        //                 [c', d', e', f']
        //                 [g', h', i', j']
        //                 [k', l', m', n'] ]
        //         
        //      (1, 2) ⋅ (2, 3, 4)            = (3, 4)

        int dimensions[3] = dims(y);
        int p = dimensions[1];
        int q = dimensions[2];
        int r = dimensions[3];
        matrix[q, r] z;
        real cell;

        if (p != num_elements(x)) {
            reject("Incompatible arguments");
        }
        for (j in 1:q) {
            for (k in 1:r) {
                cell = 0.0;
                for (i in 1:p) {
                    cell += x[i] * y[i, j, k];
                }
                z[j, k] = cell;
            }
        }
        return z;
    }

    real[,] tensordot_A3_2(real[] x, real[,,] y)
    {
        // As for tensordot_A3_M(), but returning an array.

        int dimensions[3] = dims(y);
        int p = dimensions[1];
        int q = dimensions[2];
        int r = dimensions[3];
        real z[q, r];
        real cell;

        if (p != num_elements(x)) {
            reject("Incompatible arguments");
        }
        for (j in 1:q) {
            for (k in 1:r) {
                cell = 0.0;
                for (i in 1:p) {
                    cell += x[i] * y[i, j, k];
                }
                z[j, k] = cell;
            }
        }
        return z;
    }

    // ------------------------------------------------------------------------
    // Pairwise differences in matrix format
    // ------------------------------------------------------------------------
    // Two functions with different signatures can't have the same name...

    matrix pairwiseDifferencesSpecifyDiagonal(vector x, vector y, 
                                              real diagonal_value)
    {
        // - Given two vectors of equal length N, returns a matrix[N, N] result
        //   where each element result[i, j] == x[i] - y[j].
        // - Diagonal values, for which i == j, are populated with
        //   diagonal_value. By default this is zero, but if this is to be a
        //   result from e.g. a generated quantities block, Stan will complain
        //   (that the largest value of Rhat is NaN) if diagonal values is unvaryingly
        //   zero. Under those circumstances, you should pass in a small (e.g.
        //   iteration-specific) random number, e.g. like this:
        //          real tiny_random_number = uniform_rng(-1e-16, 1e-16);
        //          group_diffs = pairwiseDifferences(x, y, tiny_random_number);

        int n = num_elements(x);
        matrix[n, n] result;
        real diff_x_minus_y;  // working variable to save a lookup

        if (n != num_elements(y)) {
            reject("Incompatible arguments");
        }
        for (j in 1:n) {  // access matrices in column-major order
            for (i in 1:n) {
                if (i == j) {
                    result[i, j] = diagonal_value;
                } else if (i > j) {
                    // We populate the bottom-left corner [i, j], where i > j,
                    // and simultaneously cross-populate the corresponding cell
                    // in the top-right corner [j, i].
                    diff_x_minus_y = x[i] - y[j];
                    result[i, j] = diff_x_minus_y;
                    result[j, i] = -diff_x_minus_y;
                }
            }
        }
        return result;
    }

    matrix pairwiseDifferences(vector x, vector y)
    {
        // A version of pairwiseDifferences() with diagonal_value = 0.

        return pairwiseDifferencesSpecifyDiagonal(x, y, 0);
    }

    matrix pairwiseDifferencesSelfSpecifyDiagonal(vector x, real diagonal_value)
    {
        // A version of pairwiseDifferences() to compare a vector to itself
        // pairwise.

        return pairwiseDifferencesSpecifyDiagonal(x, x, diagonal_value);
    }

    matrix pairwiseDifferencesSelf(vector x)
    {
        // A version of pairwiseDifferences() to compare a vector to itself
        // pairwise with diagonal_value = 0.

        return pairwiseDifferencesSpecifyDiagonal(x, x, 0);
    }

    // ------------------------------------------------------------------------
    // Pairwise comparisons in vector format
    // ------------------------------------------------------------------------

    int factorial(int x);  // necessary for self-recursion
    int factorial(int x)
    {
        // We could use tgamma(x + 1). But then we run into the unwillingness
        // of Stan to provide functions that round real numbers to integer, and
        // the need for complex workarounds:
        // https://discourse.mc-stan.org/t/real-to-integer-conversion/5622/9 So
        // we could just implement a factorial algorithm; see
        // http://www.luschny.de/math/factorial/FastFactorialFunctions.htm We
        // will just use the simplest version:

        if (x < 0) {
            reject("Factorial undefined for negative numbers. Called for: ", x);
        }
        if (x == 0 || x == 1) {
            return 1;  // 0! = 1, and 1! = 1
        }
        return x * factorial(x - 1);
    }

    int nCombinations(int n, int k)
    {
        // Returns the number of combinations of size k amongst n items.
        //
        // The two-stage approach is entirely because of a wrong warning
        // message from Stan. If you use
        //    return factorial(n) / (factorial(k) * factorial(n - k));
        // then the integer division warning in Stan will print
        //    factorial(n) / factorial(k) * factorial(n - k);
        // ... the removal of the brackets in the warning message may make the
        // reader think the code is wrong.

        int denominator;
        if (n < 1 || k < 1 || n - k < 0) {
            return 0;
        }
        denominator = factorial(k) * factorial(n - k);
        return factorial(n) / denominator;  // will produce a Stan info message
    }

    vector pairwiseDifferencesVec(vector x)
    {
        // Given a vector x of length n (where n > 1), returns a vector of
        // length C(n, 2) of every pairwise comparison.
        //
        // The first pairwise comparisons is x[1] - x[2], then x[1] - x[3],
        // etc., up to x[1] - x[n]. Then it moves to x[2] - x[3], x[2] - x[4],
        // etc. And so on; the last element is x[n - 1] - x[n].
        //
        // The inverse comparisons, e.g. x[2] - x[1], are not performed.

        int n_items = num_elements(x);
        int n_pairs = nCombinations(n_items, 2);
        int pair = 1;
        vector[n_pairs] differences;
        if (n_pairs < 1) {
            return differences;  // empty vector
        }

        for (i in 1:(n_items - 1)) {
            for (j in (i + 1):n_items) {
                differences[pair] = x[i] - x[j];
                pair += 1;
            }
        }
        return differences;
    }

    vector pairwiseDifferencesVecNPairsKnown(vector x, int n_pairs)
    {
        // As for pairwiseDifferencesVec, but with n_pairs precalculated
        // for speed. (The caller will need to have precalculated this to
        // define the size of the return vector...)

        int n_items = num_elements(x);
        int pair = 1;
        vector[n_pairs] differences;
        if (n_pairs < 1) {
            return differences;  // empty vector
        }

        for (i in 1:(n_items - 1)) {
            for (j in (i + 1):n_items) {
                differences[pair] = x[i] - x[j];
                pair += 1;
            }
        }
        return differences;
    }

    // ------------------------------------------------------------------------
    // AUROC (area under the receiver operating characteristic curve)
    // ------------------------------------------------------------------------

    real aurocAV(int[] binary_outcome, vector probability)
    {
        /*

            Calculates AUROC for a binary dependent variable "outcome" from the
            predictor "probability", range [0, 1], where this is the calculated
            probability of the binary variable being 1.

            CONCEPT

            See:

            - https://stats.stackexchange.com/questions/145566/how-to-calculate-area-under-the-curve-auc-or-the-c-statistic-by-hand
            - https://www.r-bloggers.com/2016/11/calculating-auc-the-area-under-a-roc-curve/
            - https://blog.revolutionanalytics.com/2016/11/calculating-auc.html

            We will use the following method in principle:

            - For every unique pair of actual values (one is 0, the other is 1):
            - If p_for_outcome_one > p_for_outcome_zero, that's a win (score 1);
              if p_for_outcome_one < p_for_outcome_zero, that's a loss (score 0);
              if p_for_outcome_one = p_for_outcome_zero, that's a tie (score 0.5).
            - Take the mean of those scores; that is the AUROC.

            This follows Hanley & McNeil (1982, PMID 7063747), section III.

            If the outcome doesn't have both ones and zeros, we fail, as in R:
                library(pROC)
                roc(response = c(1, 1, 1, 1), predictor = c(0.1, 0.2, 0.3, 0.4))

            General speedup techniques:
                https://mc-stan.org/docs/2_27/stan-users-guide/vectorization.html

            However, see this algorithm:

            - https://stephanosterburg.gitbook.io/scrapbook/data-science/ds-cheatsheets/machine-learning/fast-computation-of-auc-roc-score

            ALGORITHM

            After:
            - https://stephanosterburg.gitbook.io/scrapbook/data-science/ds-cheatsheets/machine-learning/fast-computation-of-auc-roc-score
            - https://github.com/jfpuget/metrics/blob/master/auc.ipynb

            "Let's first define some entities.

            - pos is the set of examples with target 1. These are the positive
              examples.
            - neg is the set of examples with target 0. These are the negative
              examples.
            - p(i) is the prediction for example i. p(i) is a number between 0
              and 1.
            - A pair of examples (i, j) is labelled the right way if i is a
              positive example, j is a negative example, and the prediction for
              i is higher than the prediction for j.
            - | s | is the number of elements in set s.

            Then AUC-ROC is the count of pairs labelled the right way divided
            by the number of pairs:

                AUC-ROC = | {(i,j), i in pos, j in neg, p(i) > p(j)} | / (| pos | * | neg |)

            A naive code to compute this would be to consider each possible
            pair and count those labelled the right way. A much better way is
            to sort the predictions first, then visit the examples in
            increasing order of predictions. Each time we see a positive
            example we add the number of negative examples we've seen so far."

            ~~~

            RNC: Accuracy verified against R's pROC::roc(); see
            rlib/tests/auroc/test_auroc_algorithm.R.
        */

        int n = num_elements(binary_outcome);
        // Sort the binary outcome by ascending probability:
        int y[n] = binary_outcome[sort_indices_asc(probability)];
        int n_false = 0;
        int current_y;
        real total = 0.0;
        for (i in 1:n) {
            current_y = y[i];
            n_false += 1 - current_y;  // add 1 if false; unchanged if true
            total += current_y * n_false;
            // ... if we are seeing a positive example, add the number of
            // negative examples so far.
        }
        return total / (n_false * (n - n_false));
    }


    // ------------------------------------------------------------------------
    // LOG PROBABILITY FUNCTIONS FOR BRIDGE SAMPLING
    // ------------------------------------------------------------------------
    /*
    We can have functions that access the log probability accumulator
    if the function name ends in '_lp'; see Stan manual section 23.3.

    RE ARGUMENTS:

    The Stan manual uses notation like
         real normal_lpdf(reals y | reals mu, reals sigma)
    but "reals" isn't something you can actually use in user functions.
    See p495:
        "reals" means:
                real
                real[]
                vector
                row_vector
        "ints" means
                int
                int[]

    Moreover, you can't define two copies of the same function with
    different names (23.6: no overloading of user-defined functions).
    For real arguments, the options are therefore:
         real
         real[]  // one-dimensional array
         real[,]  // two-dimensional array
         real[,,]  // three-dimensional array (... etc.)
         vector  // vector, similar to a one-dimensional array.
         matrix  // matrix, similar to a two-dimensional array.
    See p297 of the 2017 Stan manual, and also p319.
    Which do we use in practice?
    - Firstly, we use single numbers or one-dimensional collections,
      and generally the latter. So that means real[] or vector.
    - We use both.
    - So let's have "Real", "Arr" and "Vec" versions.
    - Then, to make things worse, we sometimes have constant parameters,
      and sometimes array/vector parameters...
    - For something with two distribution parameters, like the normal
      distribution and many others, that means that we have 3*3*3 combinations
      for each thing. Urgh. Stan should allow user overloading ;).
    - Let's do it and define "R", "A", "2", "3", "V" for the parameters.
      (Also "M" for matrix.)
    - Except we won't be returning R unless it's RRR!
    - Last thing cycles fastest.
    So:
        RRR
        -- nothing else R*

        ARA
        ARV
        AAR
        AAA
        AAV
        AVR
        AVA
        AVV

        2RR
            ...

        3RR
            ...

        VRA
        VRV
        VAR
        VAA
        VAV
        VVR
        VVA
        VVV

    RE SAMPLING TWO-DIMENSIONAL ARRAYS:

    You can't sample an entire matrix or 2D array; you have do to it row-wise.
    - This isn't very clear in the manual, as far as I can see.
    - The definition of e.g. beta_lpdf() is in terms of "reals", which
      probably means a vector or array of real.
    - Section 9.6 ("Multi-logit regression") of the Stan manual v2.16.0
      gives an example where one would use a matrix sampling statement but
      they don't.
    - But it is explicit in the sense that they define what they mean by
      "reals", as above, and that doesn't include 2D arrays.
    - Better to move the boilerplate code here than in user land, though.

    RE TWO-DIMENSIONAL ARRAYS:

        real thing[N_A, N_B];

        // One way to iterate through all elements:
        for (a in 1:N_A) {
            for (b in 1:N_B) {
                do_something(thing[a, b]);
            }
        }

        // NOT another way to iterate through all elements:
        for (i in 1:num_elements(thing)) {
            do_something(thing[i]);  // thing[i] is a real[], not a real
            // ... and thing[num_elements(thing)] will be an index overflow
        }

    So for some functions we want real[,]... let's give this the one-character
    notation "2" (for 2D array).

    Now:
        num_elements() gives the total, in this case N_A * N_B;
            ... but when *accessing* a 2D array, my_array[1] gives the first
                row, not the first element; see Stan 2017 manual p323.
        size() gives the size of first dimension, in this case N_A;
        dims() gives all dimensions, in this case an int[] containing {N_A, N_B}.

    RE ARITHMETIC:

    Note that we cannot do:
            real * real[]
            vector * vector

    */

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Helper functions for boundary checking
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // For the use of "target += negative_infinity()" with truncation, see Stan
    // (2017, v2.16.0) manual p82, or e.g.
    // https://mc-stan.org/docs/2_25/reference-manual/sampling-statements-section.html#truncation-with-lower-and-upper-bounds-in-stan
    //
    // These are internal functions that ASSUME size match.

    // Lower

    void enforceLowerBound_R_lp(real y, real lower)
    {
        if (y < lower) {
            target += negative_infinity();
        }
    }
    void enforceLowerBound_A_lp(real[] y, real lower)
    {
        for (i in 1:num_elements(y)) {
            if (y[i] < lower) {
                target += negative_infinity();
                return;
            }
        }
    }
    void enforceLowerBound_2_lp(real[,] y, real lower)
    {
        int dimensions[2] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                if (y[i, j] < lower) {
                    target += negative_infinity();
                    return;
                }
            }
        }
    }
    void enforceLowerBound_3_lp(real[,,] y, real lower)
    {
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    if (y[i, j, k] < lower) {
                        target += negative_infinity();
                        return;
                    }
                }
            }
        }
    }
    void enforceLowerBound_V_lp(vector y, real lower)
    {
        for (i in 1:num_elements(y)) {
            if (y[i] < lower) {
                target += negative_infinity();
                return;
            }
        }
    }

    // Upper

    void enforceUpperBound_R_lp(real y, real upper)
    {
        if (y > upper) {
            target += negative_infinity();
        }
    }
    void enforceUpperBound_A_lp(real[] y, real upper)
    {
        for (i in 1:num_elements(y)) {
            if (y[i] > upper) {
                target += negative_infinity();
                return;
            }
        }
    }
    void enforceUpperBound_2_lp(real[,] y, real upper)
    {
        int dimensions[2] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                if (y[i, j] > upper) {
                    target += negative_infinity();
                    return;
                }
            }
        }
    }
    void enforceUpperBound_3_lp(real[,,] y, real upper)
    {
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    if (y[i, j, k] > upper) {
                        target += negative_infinity();
                        return;
                    }
                }
            }
        }
    }
    void enforceUpperBound_V_lp(vector y, real upper)
    {
        for (i in 1:num_elements(y)) {
            if (y[i] > upper) {
                target += negative_infinity();
                return;
            }
        }
    }

    // Range

    void enforceRangeBounds_R_lp(real y, real lower, real upper)
    {
        if (y < lower || y > upper) {
            target += negative_infinity();
        }
    }
    void enforceRangeBounds_A_lp(real[] y, real lower, real upper)
    {
        real value;
        for (i in 1:num_elements(y)) {
            value = y[i];  // lookup only once
            if (value < lower || value > upper) {
                target += negative_infinity();
                return;
            }
        }
    }
    void enforceRangeBounds_2_lp(real[,] y, real lower, real upper)
    {
        int dimensions[2] = dims(y);
        real value;
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                value = y[i, j];  // lookup only once
                if (value < lower || value > upper) {
                    target += negative_infinity();
                    return;
                }
            }
        }
    }
    void enforceRangeBounds_3_lp(real[,,] y, real lower, real upper)
    {
        int dimensions[3] = dims(y);
        real value;
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    value = y[i, j, k];  // lookup only once
                    if (value < lower || value > upper) {
                        target += negative_infinity();
                        return;
                    }
                }
            }
        }
    }
    void enforceRangeBounds_V_lp(vector y, real lower, real upper)
    {
        real value;
        for (i in 1:num_elements(y)) {
            value = y[i];  // lookup only once
            if (value < lower || value > upper) {
                target += negative_infinity();
                return;
            }
        }
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Normal distribution
    // - mu is the mean; sigma is the standard deviation
    // - See Stan 2.16.0 manual p512;
    //   http://mathworld.wolfram.com/NormalDistribution.html
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    // Sampling

    void sampleNormal_RRR_lp(real y, real mu, real sigma)
    {
        target += normal_lpdf(y | mu, sigma);
    }

    void sampleNormal_ARR_lp(real[] y, real mu, real sigma)
    {
        target += normal_lpdf(y | mu, sigma);
    }

    void sampleNormal_2RR_lp(real[,] y, real mu, real sigma)
    {
        for (i in 1:size(y)) {
            target += normal_lpdf(y[i] | mu, sigma);
            // ... y[i] is a one-dimensional array
        }
    }

    void sampleNormal_3RR_lp(real[,,] y, real mu, real sigma)
    {
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += normal_lpdf(y[i, j, k] | mu, sigma);
                }
            }
        }
    }

    void sampleNormal_VRR_lp(vector y, real mu, real sigma)
    {
        target += normal_lpdf(y | mu, sigma);
    }

    // Sampling with lower bound

    void sampleNormalLowerBound_RRR_lp(real y, real mu, real sigma, real lower)
    {
        real correction_per_value = normal_lccdf(lower | mu, sigma);
        target += normal_lpdf(y | mu, sigma) -
                  correction_per_value;
        enforceLowerBound_R_lp(y, lower);
    }

    void sampleNormalLowerBound_ARR_lp(real[] y, real mu, real sigma, real lower)
    {
        real correction_per_value = normal_lccdf(lower | mu, sigma);
        target += normal_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceLowerBound_A_lp(y, lower);
    }

    void sampleNormalLowerBound_2RR_lp(real[,] y, real mu, real sigma, real lower)
    {
        real correction_per_value = normal_lccdf(lower | mu, sigma);
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += normal_lpdf(y[i] | mu, sigma) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceLowerBound_2_lp(y, lower);
    }

    void sampleNormalLowerBound_3RR_lp(real[,,] y, real mu, real sigma, real lower)
    {
        real correction_per_value = normal_lccdf(lower | mu, sigma);
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += normal_lpdf(y[i, j, k] | mu, sigma) -
                              correction_per_value;
                }
            }
        }
        enforceLowerBound_3_lp(y, lower);
    }

    void sampleNormalLowerBound_VRR_lp(vector y, real mu, real sigma, real lower)
    {
        real correction_per_value = normal_lccdf(lower | mu, sigma);
        target += normal_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceLowerBound_V_lp(y, lower);
    }

    // Sampling with upper bound

    void sampleNormalUpperBound_RRR_lp(real y, real mu, real sigma, real upper)
    {
        real correction_per_value = normal_lcdf(upper | mu, sigma);
        target += normal_lpdf(y | mu, sigma) -
                  correction_per_value;
        enforceUpperBound_R_lp(y, upper);
    }

    void sampleNormalUpperBound_ARR_lp(real[] y, real mu, real sigma, real upper)
    {
        real correction_per_value = normal_lcdf(upper | mu, sigma);
        target += normal_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceUpperBound_A_lp(y, upper);
    }

    void sampleNormalUpperBound_2RR_lp(real[,] y, real mu, real sigma, real upper)
    {
        real correction_per_value = normal_lcdf(upper | mu, sigma);
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += normal_lpdf(y[i] | mu, sigma) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceUpperBound_2_lp(y, upper);
    }

    void sampleNormalUpperBound_3RR_lp(real[,,] y, real mu, real sigma, real upper)
    {
        real correction_per_value = normal_lcdf(upper | mu, sigma);
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += normal_lpdf(y[i, j, k] | mu, sigma) -
                              correction_per_value;
                }
            }
        }
        enforceUpperBound_3_lp(y, upper);
    }

    void sampleNormalUpperBound_VRR_lp(vector y, real mu, real sigma, real upper)
    {
        real correction_per_value = normal_lcdf(upper | mu, sigma);
        target += normal_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceUpperBound_V_lp(y, upper);
    }

    // Sampling with range (lower and upper) bounds

    void sampleNormalRangeBound_RRR_lp(real y, real mu, real sigma, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            normal_lcdf(upper | mu, sigma),
            normal_lcdf(lower | mu, sigma));
        target += normal_lpdf(y | mu, sigma) -
                  correction_per_value;
        enforceRangeBounds_R_lp(y, lower, upper);
    }

    void sampleNormalRangeBound_ARR_lp(real[] y, real mu, real sigma, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            normal_lcdf(upper | mu, sigma),
            normal_lcdf(lower | mu, sigma));
        target += normal_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceRangeBounds_A_lp(y, lower, upper);
    }

    void sampleNormalRangeBound_2RR_lp(real[,] y, real mu, real sigma, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            normal_lcdf(upper | mu, sigma),
            normal_lcdf(lower | mu, sigma));
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += normal_lpdf(y[i] | mu, sigma) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceRangeBounds_2_lp(y, lower, upper);
    }

    void sampleNormalRangeBound_3RR_lp(real[,,] y, real mu, real sigma, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            normal_lcdf(upper | mu, sigma),
            normal_lcdf(lower | mu, sigma));
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += normal_lpdf(y[i, j, k] | mu, sigma) -
                              correction_per_value;
                }
            }
        }
        enforceRangeBounds_3_lp(y, lower, upper);
    }

    void sampleNormalRangeBound_VRR_lp(vector y, real mu, real sigma, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            normal_lcdf(upper | mu, sigma),
            normal_lcdf(lower | mu, sigma));
        target += normal_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceRangeBounds_V_lp(y, lower, upper);
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Standard normal distribution, N(0,1)
    // - Note that we have to use normal_lcdf (etc.) but can use
    //   std_normal_lpdf.
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    // Sampling

    void sampleStdNormal_R_lp(real y)
    {
        target += std_normal_lpdf(y);
    }

    void sampleStdNormal_A_lp(real[] y)
    {
        target += std_normal_lpdf(y);
    }

    void sampleStdNormal_2_lp(real[,] y)
    {
        for (i in 1:size(y)) {
            target += std_normal_lpdf(y[i]);
            // ... y[i] is a one-dimensional array
        }
    }

    void sampleStdNormal_3_lp(real[,,] y)
    {
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += std_normal_lpdf(y[i, j, k]);
                }
            }
        }
    }

    void sampleStdNormal_V_lp(vector y)
    {
        target += std_normal_lpdf(y);
    }

    // Sampling with lower bound

    void sampleStdNormalLowerBound_R_lp(real y, real lower)
    {
        real correction_per_value = normal_lccdf(lower | 0, 1);
        target += std_normal_lpdf(y) -
                  correction_per_value;
        enforceLowerBound_R_lp(y, lower);
    }

    void sampleStdNormalLowerBound_A_lp(real[] y, real lower)
    {
        real correction_per_value = normal_lccdf(lower | 0, 1);
        target += std_normal_lpdf(y) -
                  correction_per_value * num_elements(y);
        enforceLowerBound_A_lp(y, lower);
    }

    void sampleStdNormalLowerBound_2_lp(real[,] y, real lower)
    {
        real correction_per_value = normal_lccdf(lower | 0, 1);
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += std_normal_lpdf(y[i]) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceLowerBound_2_lp(y, lower);
    }

    void sampleStdNormalLowerBound_3_lp(real[,,] y, real lower)
    {
        real correction_per_value = normal_lccdf(lower | 0, 1);
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += std_normal_lpdf(y[i, j, k]) -
                              correction_per_value;
                }
            }
        }
        enforceLowerBound_3_lp(y, lower);
    }

    void sampleStdNormalLowerBound_V_lp(vector y, real lower)
    {
        real correction_per_value = normal_lccdf(lower | 0, 1);
        target += std_normal_lpdf(y) -
                  correction_per_value * num_elements(y);
        enforceLowerBound_V_lp(y, lower);
    }

    // Sampling with upper bound

    void sampleStdNormalUpperBound_R_lp(real y, real upper)
    {
        real correction_per_value = normal_lcdf(upper | 0, 1);
        target += std_normal_lpdf(y) -
                  correction_per_value;
        enforceUpperBound_R_lp(y, upper);
    }

    void sampleStdNormalUpperBound_A_lp(real[] y, real upper)
    {
        real correction_per_value = normal_lcdf(upper | 0, 1);
        target += std_normal_lpdf(y) -
                  correction_per_value * num_elements(y);
        enforceUpperBound_A_lp(y, upper);
    }

    void sampleStdNormalUpperBound_2_lp(real[,] y, real upper)
    {
        real correction_per_value = normal_lcdf(upper | 0, 1);
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += std_normal_lpdf(y[i]) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceUpperBound_2_lp(y, upper);
    }

    void sampleStdNormalUpperBound_3_lp(real[,,] y, real upper)
    {
        real correction_per_value = normal_lcdf(upper | 0, 1);
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += std_normal_lpdf(y[i, j, k]) -
                              correction_per_value;
                }
            }
        }
        enforceUpperBound_3_lp(y, upper);
    }

    void sampleStdNormalUpperBound_V_lp(vector y, real upper)
    {
        real correction_per_value = normal_lcdf(upper | 0, 1);
        target += std_normal_lpdf(y) -
                  correction_per_value * num_elements(y);
        enforceUpperBound_V_lp(y, upper);
    }

    // Sampling with range (lower and upper) bounds

    void sampleStdNormalRangeBound_R_lp(real y, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            normal_lcdf(upper | 0, 1),
            normal_lcdf(lower | 0, 1));
        target += std_normal_lpdf(y) -
                  correction_per_value;
        enforceRangeBounds_R_lp(y, lower, upper);
    }

    void sampleStdNormalRangeBound_A_lp(real[] y, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            normal_lcdf(upper | 0, 1),
            normal_lcdf(lower | 0, 1));
        target += std_normal_lpdf(y) -
                  correction_per_value * num_elements(y);
        enforceRangeBounds_A_lp(y, lower, upper);
    }

    void sampleStdNormalRangeBound_2_lp(real[,] y, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            normal_lcdf(upper | 0, 1),
            normal_lcdf(lower | 0, 1));
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += std_normal_lpdf(y[i]) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceRangeBounds_2_lp(y, lower, upper);
    }

    void sampleStdNormalRangeBound_3_lp(real[,,] y, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            normal_lcdf(upper | 0, 1),
            normal_lcdf(lower | 0, 1));
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += std_normal_lpdf(y[i, j, k]) -
                              correction_per_value;
                }
            }
        }
        enforceRangeBounds_3_lp(y, lower, upper);
    }

    void sampleStdNormalRangeBound_V_lp(vector y, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            normal_lcdf(upper | 0, 1),
            normal_lcdf(lower | 0, 1));
        target += std_normal_lpdf(y) -
                  correction_per_value * num_elements(y);
        enforceRangeBounds_V_lp(y, lower, upper);
    }


    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Specials for half-standard-normal, constrained to be positive
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    void sampleStdNormalPositive_R_lp(real y)
    {
        sampleStdNormalLowerBound_R_lp(y, 0);
    }

    void sampleStdNormalPositive_A_lp(real[] y, real lower)
    {
        sampleStdNormalLowerBound_A_lp(y, 0);
    }

    void sampleStdNormalPositive_2_lp(real[,] y, real lower)
    {
        sampleStdNormalLowerBound_2_lp(y, 0);
    }

    void sampleStdNormalPositive_3_lp(real[,,] y, real lower)
    {
        sampleStdNormalLowerBound_3_lp(y, 0);
    }

    void sampleStdNormalPositive_V_lp(vector y, real lower)
    {
        sampleStdNormalLowerBound_V_lp(y, 0);
    }


    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Cauchy distribution
    // - mu is location parameter; sigma is scale parameter
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    // Sampling

    void sampleCauchy_RRR_lp(real y, real mu, real sigma)
    {
        target += cauchy_lpdf(y | mu, sigma);
    }

    void sampleCauchy_ARR_lp(real[] y, real mu, real sigma)
    {
        target += cauchy_lpdf(y | mu, sigma);
    }

    void sampleCauchy_2RR_lp(real[,] y, real mu, real sigma)
    {
        for (i in 1:size(y)) {
            target += cauchy_lpdf(y[i] | mu, sigma);
            // ... y[i] is a one-dimensional array
        }
    }

    void sampleCauchy_3RR_lp(real[,,] y, real mu, real sigma)
    {
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += cauchy_lpdf(y[i, j, k] | mu, sigma);
                }
            }
        }
    }

    void sampleCauchy_VRR_lp(vector y, real mu, real sigma)
    {
        target += cauchy_lpdf(y | mu, sigma);
    }

    // Sampling with lower bound

    void sampleCauchyLowerBound_RRR_lp(real y, real mu, real sigma, real lower)
    {
        real correction_per_value = cauchy_lccdf(lower | mu, sigma);
        target += cauchy_lpdf(y | mu, sigma) -
                  correction_per_value;
        enforceLowerBound_R_lp(y, lower);
    }

    void sampleCauchyLowerBound_ARR_lp(real[] y, real mu, real sigma, real lower)
    {
        real correction_per_value = cauchy_lccdf(lower | mu, sigma);
        target += cauchy_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceLowerBound_A_lp(y, lower);
    }

    void sampleCauchyLowerBound_2RR_lp(real[,] y, real mu, real sigma, real lower)
    {
        real correction_per_value = cauchy_lccdf(lower | mu, sigma);
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += cauchy_lpdf(y[i] | mu, sigma) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceLowerBound_2_lp(y, lower);
    }

    void sampleCauchyLowerBound_3RR_lp(real[,,] y, real mu, real sigma, real lower)
    {
        real correction_per_value = cauchy_lccdf(lower | mu, sigma);
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += cauchy_lpdf(y[i, j, k] | mu, sigma) -
                              correction_per_value;
                }
            }
        }
        enforceLowerBound_3_lp(y, lower);
    }

    void sampleCauchyLowerBound_VRR_lp(vector y, real mu, real sigma, real lower)
    {
        real correction_per_value = cauchy_lccdf(lower | mu, sigma);
        target += cauchy_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceLowerBound_V_lp(y, lower);
    }

    // Sampling with upper bound

    void sampleCauchyUpperBound_RRR_lp(real y, real mu, real sigma, real upper)
    {
        real correction_per_value = cauchy_lcdf(upper | mu, sigma);
        target += cauchy_lpdf(y | mu, sigma) -
                  correction_per_value;
        enforceUpperBound_R_lp(y, upper);
    }

    void sampleCauchyUpperBound_ARR_lp(real[] y, real mu, real sigma, real upper)
    {
        real correction_per_value = cauchy_lcdf(upper | mu, sigma);
        target += cauchy_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceUpperBound_A_lp(y, upper);
    }

    void sampleCauchyUpperBound_2RR_lp(real[,] y, real mu, real sigma, real upper)
    {
        real correction_per_value = cauchy_lcdf(upper | mu, sigma);
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += cauchy_lpdf(y[i] | mu, sigma) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceUpperBound_2_lp(y, upper);
    }

    void sampleCauchyUpperBound_3RR_lp(real[,,] y, real mu, real sigma, real upper)
    {
        real correction_per_value = cauchy_lcdf(upper | mu, sigma);
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += cauchy_lpdf(y[i, j, k] | mu, sigma) -
                              correction_per_value;
                }
            }
        }
        enforceUpperBound_3_lp(y, upper);
    }

    void sampleCauchyUpperBound_VRR_lp(vector y, real mu, real sigma, real upper)
    {
        real correction_per_value = cauchy_lcdf(upper | mu, sigma);
        target += cauchy_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceUpperBound_V_lp(y, upper);
    }

    // Sampling with range (lower and upper) bounds

    void sampleCauchyRangeBound_RRR_lp(real y, real mu, real sigma, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            cauchy_lcdf(upper | mu, sigma),
            cauchy_lcdf(lower | mu, sigma));
        target += cauchy_lpdf(y | mu, sigma) -
                  correction_per_value;
        enforceRangeBounds_R_lp(y, lower, upper);
    }

    void sampleCauchyRangeBound_ARR_lp(real[] y, real mu, real sigma, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            cauchy_lcdf(upper | mu, sigma),
            cauchy_lcdf(lower | mu, sigma));
        target += cauchy_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceRangeBounds_A_lp(y, lower, upper);
    }

    void sampleCauchyRangeBound_2RR_lp(real[,] y, real mu, real sigma, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            cauchy_lcdf(upper | mu, sigma),
            cauchy_lcdf(lower | mu, sigma));
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += cauchy_lpdf(y[i] | mu, sigma) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceRangeBounds_2_lp(y, lower, upper);
    }

    void sampleCauchyRangeBound_3RR_lp(real[,,] y, real mu, real sigma, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            cauchy_lcdf(upper | mu, sigma),
            cauchy_lcdf(lower | mu, sigma));
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += cauchy_lpdf(y[i, j, k] | mu, sigma) -
                              correction_per_value;
                }
            }
        }
        enforceRangeBounds_3_lp(y, lower, upper);
    }

    void sampleCauchyRangeBound_VRR_lp(vector y, real mu, real sigma, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            cauchy_lcdf(upper | mu, sigma),
            cauchy_lcdf(lower | mu, sigma));
        target += cauchy_lpdf(y | mu, sigma) -
                  correction_per_value * num_elements(y);
        enforceRangeBounds_V_lp(y, lower, upper);
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Beta distribution
    // - In R, alpha is called scale1, and beta is called scale2.
    // - Its distribution is confined to the range [0, 1]. See
    //   https://en.wikipedia.org/wiki/Beta_distribution. In R, try:
    //
    //   curve(dbeta(x, shape1 = 1.2, shape2 = 1.2), -0.1, 1.1, ylab = "density")
    //
    // - Stan 2.16.0 manual p532; R ?dbeta;
    //   https://www.rdocumentation.org/packages/visualize/versions/4.3.0/topics/visualize.beta
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    // Sampling

    void sampleBeta_RRR_lp(real y, real alpha, real beta)
    {
        target += beta_lpdf(y | alpha, beta);
    }

    void sampleBeta_ARR_lp(real[] y, real alpha, real beta)
    {
        target += beta_lpdf(y | alpha, beta);
    }

    void sampleBeta_2RR_lp(real[,] y, real alpha, real beta)
    {
        for (i in 1:size(y)) {
            target += beta_lpdf(y[i] | alpha, beta);
            // ... y[i] is a one-dimensional array
        }
    }

    void sampleBeta_3RR_lp(real[,,] y, real alpha, real beta)
    {
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += beta_lpdf(y[i, j, k] | alpha, beta);
                }
            }
        }
    }

    void sampleBeta_VRR_lp(vector y, real alpha, real beta)
    {
        target += beta_lpdf(y | alpha, beta);
    }

    // Sampling with lower bound

    void sampleBetaLowerBound_RRR_lp(real y, real alpha, real beta, real lower)
    {
        real correction_per_value = beta_lccdf(lower | alpha, beta);
        target += beta_lpdf(y | alpha, beta) -
                  correction_per_value;
        enforceLowerBound_R_lp(y, lower);
    }

    void sampleBetaLowerBound_ARR_lp(real[] y, real alpha, real beta, real lower)
    {
        real correction_per_value = beta_lccdf(lower | alpha, beta);
        target += beta_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceLowerBound_A_lp(y, lower);
    }

    void sampleBetaLowerBound_2RR_lp(real[,] y, real alpha, real beta, real lower)
    {
        real correction_per_value = beta_lccdf(lower | alpha, beta);
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += beta_lpdf(y[i] | alpha, beta) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceLowerBound_2_lp(y, lower);
    }

    void sampleBetaLowerBound_3RR_lp(real[,,] y, real alpha, real beta, real lower)
    {
        real correction_per_value = beta_lccdf(lower | alpha, beta);
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += beta_lpdf(y[i, j, k] | alpha, beta) -
                              correction_per_value;
                }
            }
        }
        enforceLowerBound_3_lp(y, lower);
    }

    void sampleBetaLowerBound_VRR_lp(vector y, real alpha, real beta, real lower)
    {
        real correction_per_value = beta_lccdf(lower | alpha, beta);
        target += beta_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceLowerBound_V_lp(y, lower);
    }

    // Sampling with upper bound

    void sampleBetaUpperBound_RRR_lp(real y, real alpha, real beta, real upper)
    {
        real correction_per_value = beta_lcdf(upper | alpha, beta);
        target += beta_lpdf(y | alpha, beta) -
                  correction_per_value;
        enforceUpperBound_R_lp(y, upper);
    }

    void sampleBetaUpperBound_ARR_lp(real[] y, real alpha, real beta, real upper)
    {
        real correction_per_value = beta_lcdf(upper | alpha, beta);
        target += beta_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceUpperBound_A_lp(y, upper);
    }

    void sampleBetaUpperBound_2RR_lp(real[,] y, real alpha, real beta, real upper)
    {
        real correction_per_value = beta_lcdf(upper | alpha, beta);
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += beta_lpdf(y[i] | alpha, beta) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceUpperBound_2_lp(y, upper);
    }

    void sampleBetaUpperBound_3RR_lp(real[,,] y, real alpha, real beta, real upper)
    {
        real correction_per_value = beta_lcdf(upper | alpha, beta);
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += beta_lpdf(y[i, j, k] | alpha, beta) -
                              correction_per_value;
                }
            }
        }
        enforceUpperBound_3_lp(y, upper);
    }

    void sampleBetaUpperBound_VRR_lp(vector y, real alpha, real beta, real upper)
    {
        real correction_per_value = beta_lcdf(upper | alpha, beta);
        target += beta_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceUpperBound_V_lp(y, upper);
    }

    // Sampling with range (lower and upper) bounds

    void sampleBetaRangeBound_RRR_lp(real y, real alpha, real beta, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            beta_lcdf(upper | alpha, beta),
            beta_lcdf(lower | alpha, beta));
        target += beta_lpdf(y | alpha, beta) -
                  correction_per_value;
        enforceRangeBounds_R_lp(y, lower, upper);
    }

    void sampleBetaRangeBound_ARR_lp(real[] y, real alpha, real beta, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            beta_lcdf(upper | alpha, beta),
            beta_lcdf(lower | alpha, beta));
        target += beta_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceRangeBounds_A_lp(y, lower, upper);
    }

    void sampleBetaRangeBound_2RR_lp(real[,] y, real alpha, real beta, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            beta_lcdf(upper | alpha, beta),
            beta_lcdf(lower | alpha, beta));
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += beta_lpdf(y[i] | alpha, beta) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceRangeBounds_2_lp(y, lower, upper);
    }

    void sampleBetaRangeBound_3RR_lp(real[,,] y, real alpha, real beta, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            beta_lcdf(upper | alpha, beta),
            beta_lcdf(lower | alpha, beta));
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += beta_lpdf(y[i, j, k] | alpha, beta) -
                              correction_per_value;
                }
            }
        }
        enforceRangeBounds_3_lp(y, lower, upper);
    }

    void sampleBetaRangeBound_VRR_lp(vector y, real alpha, real beta, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            beta_lcdf(upper | alpha, beta),
            beta_lcdf(lower | alpha, beta));
        target += beta_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceRangeBounds_V_lp(y, lower, upper);
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Gamma distribution
    // - Stan's alpha is R's shape; Stan's beta is R's rate.
    //   (R also offers scale = 1/rate.)
    // - https://en.wikipedia.org/wiki/Gamma_distribution
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    // Sampling

    void sampleGamma_RRR_lp(real y, real alpha, real beta)
    {
        target += gamma_lpdf(y | alpha, beta);
    }

    void sampleGamma_ARR_lp(real[] y, real alpha, real beta)
    {
        target += gamma_lpdf(y | alpha, beta);
    }

    void sampleGamma_2RR_lp(real[,] y, real alpha, real beta)
    {
        for (i in 1:size(y)) {
            target += gamma_lpdf(y[i] | alpha, beta);
            // ... y[i] is a one-dimensional array
        }
    }

    void sampleGamma_3RR_lp(real[,,] y, real alpha, real beta)
    {
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += gamma_lpdf(y[i, j, k] | alpha, beta);
                }
            }
        }
    }

    void sampleGamma_VRR_lp(vector y, real alpha, real beta)
    {
        target += gamma_lpdf(y | alpha, beta);
    }

    // Sampling with lower bound

    void sampleGammaLowerBound_RRR_lp(real y, real alpha, real beta, real lower)
    {
        real correction_per_value = gamma_lccdf(lower | alpha, beta);
        target += gamma_lpdf(y | alpha, beta) -
                  correction_per_value;
        enforceLowerBound_R_lp(y, lower);
    }

    void sampleGammaLowerBound_ARR_lp(real[] y, real alpha, real beta, real lower)
    {
        real correction_per_value = gamma_lccdf(lower | alpha, beta);
        target += gamma_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceLowerBound_A_lp(y, lower);
    }

    void sampleGammaLowerBound_2RR_lp(real[,] y, real alpha, real beta, real lower)
    {
        real correction_per_value = gamma_lccdf(lower | alpha, beta);
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += gamma_lpdf(y[i] | alpha, beta) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceLowerBound_2_lp(y, lower);
    }

    void sampleGammaLowerBound_3RR_lp(real[,,] y, real alpha, real beta, real lower)
    {
        real correction_per_value = gamma_lccdf(lower | alpha, beta);
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += gamma_lpdf(y[i, j, k] | alpha, beta) -
                              correction_per_value;
                }
            }
        }
        enforceLowerBound_3_lp(y, lower);
    }

    void sampleGammaLowerBound_VRR_lp(vector y, real alpha, real beta, real lower)
    {
        real correction_per_value = gamma_lccdf(lower | alpha, beta);
        target += gamma_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceLowerBound_V_lp(y, lower);
    }

    // Sampling with upper bound

    void sampleGammaUpperBound_RRR_lp(real y, real alpha, real beta, real upper)
    {
        real correction_per_value = gamma_lcdf(upper | alpha, beta);
        target += gamma_lpdf(y | alpha, beta) -
                  correction_per_value;
        enforceUpperBound_R_lp(y, upper);
    }

    void sampleGammaUpperBound_ARR_lp(real[] y, real alpha, real beta, real upper)
    {
        real correction_per_value = gamma_lcdf(upper | alpha, beta);
        target += gamma_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceUpperBound_A_lp(y, upper);
    }

    void sampleGammaUpperBound_2RR_lp(real[,] y, real alpha, real beta, real upper)
    {
        real correction_per_value = gamma_lcdf(upper | alpha, beta);
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += gamma_lpdf(y[i] | alpha, beta) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceUpperBound_2_lp(y, upper);
    }

    void sampleGammaUpperBound_3RR_lp(real[,,] y, real alpha, real beta, real upper)
    {
        real correction_per_value = gamma_lcdf(upper | alpha, beta);
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += gamma_lpdf(y[i, j, k] | alpha, beta) -
                              correction_per_value;
                }
            }
        }
        enforceUpperBound_3_lp(y, upper);
    }

    void sampleGammaUpperBound_VRR_lp(vector y, real alpha, real beta, real upper)
    {
        real correction_per_value = gamma_lcdf(upper | alpha, beta);
        target += gamma_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceUpperBound_V_lp(y, upper);
    }

    // Sampling with range (lower and upper) bounds

    void sampleGammaRangeBound_RRR_lp(real y, real alpha, real beta, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            gamma_lcdf(upper | alpha, beta),
            gamma_lcdf(lower | alpha, beta));
        target += gamma_lpdf(y | alpha, beta) -
                  correction_per_value;
        enforceRangeBounds_R_lp(y, lower, upper);
    }

    void sampleGammaRangeBound_ARR_lp(real[] y, real alpha, real beta, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            gamma_lcdf(upper | alpha, beta),
            gamma_lcdf(lower | alpha, beta));
        target += gamma_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceRangeBounds_A_lp(y, lower, upper);
    }

    void sampleGammaRangeBound_2RR_lp(real[,] y, real alpha, real beta, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            gamma_lcdf(upper | alpha, beta),
            gamma_lcdf(lower | alpha, beta));
        int dimensions[2] = dims(y);
        real correction_per_row = correction_per_value * dimensions[2];
        for (i in 1:dimensions[1]) {
            target += gamma_lpdf(y[i] | alpha, beta) -
                      correction_per_row;
            // ... y[i] is a one-dimensional array
        }
        enforceRangeBounds_2_lp(y, lower, upper);
    }

    void sampleGammaRangeBound_3RR_lp(real[,,] y, real alpha, real beta, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            gamma_lcdf(upper | alpha, beta),
            gamma_lcdf(lower | alpha, beta));
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += gamma_lpdf(y[i, j, k] | alpha, beta) -
                              correction_per_value;
                }
            }
        }
        enforceRangeBounds_3_lp(y, lower, upper);
    }

    void sampleGammaRangeBound_VRR_lp(vector y, real alpha, real beta, real lower, real upper)
    {
        real correction_per_value = log_diff_exp(
            gamma_lcdf(upper | alpha, beta),
            gamma_lcdf(lower | alpha, beta));
        target += gamma_lpdf(y | alpha, beta) -
                  correction_per_value * num_elements(y);
        enforceRangeBounds_V_lp(y, lower, upper);
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Uniform distribution
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Always constrained with both a lower and an upper bound.
    // Simple; no extra work for the bridge sampler.
    
    // Sampling

    void sampleUniform_RRR_lp(real y, real lower, real upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_ARR_lp(real[] y, real lower, real upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_ARA_lp(real[] y, real lower, real[] upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_ARV_lp(real[] y, real lower, vector upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_AAR_lp(real[] y, real[] lower, real upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_AAA_lp(real[] y, real[] lower, real[] upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_AAV_lp(real[] y, real[] lower, vector upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_AVR_lp(real[] y, vector lower, real upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_AVA_lp(real[] y, vector lower, real[] upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_AVV_lp(real[] y, vector lower, vector upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_2RR_lp(real[,] y, real lower, real upper)
    {
        for (i in 1:size(y)) {
            target += uniform_lpdf(y[i] | lower, upper);
            // ... y[i] is a one-dimensional array
        }
    }
    
    void sampleUniform_3RR_lp(real[,,] y, real lower, real upper)
    {
        int dimensions[3] = dims(y);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    target += uniform_lpdf(y[i, j, k] | lower, upper);
                }
            }
        }
    }
    
    void sampleUniform_VRR_lp(vector y, real lower, real upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_VRA_lp(vector y, real lower, real[] upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_VRV_lp(vector y, real lower, vector upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_VAR_lp(vector y, real[] lower, real upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_VAA_lp(vector y, real[] lower, real[] upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_VAV_lp(vector y, real[] lower, vector upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_VVR_lp(vector y, vector lower, real upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_VVA_lp(vector y, vector lower, real[] upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    void sampleUniform_VVV_lp(vector y, vector lower, vector upper)
    {
        target += uniform_lpdf(y | lower, upper);
    }
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Bernoulli distribution
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // y is in {0, 1} and theta is a probability in the range [0, 1].

    void sampleBernoulli_IR_lp(int y, real theta)
    {
        target += bernoulli_lpmf(y | theta);
    }
    void sampleBernoulli_AR_lp(int[] y, real theta)
    {
        target += bernoulli_lpmf(y | theta);
    }
    void sampleBernoulli_AA_lp(int[] y, real[] theta)
    {
        target += bernoulli_lpmf(y | theta);
    }
    void sampleBernoulli_AV_lp(int[] y, vector theta)
    {
        target += bernoulli_lpmf(y | theta);
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Bernoulli logit distribution
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // y is in {0, 1} and alpha is a logit (log odds) in the range [-inf, +inf].

    void sampleBernoulliLogit_IR_lp(int y, real alpha)
    {
        target += bernoulli_logit_lpmf(y | alpha);
    }
    void sampleBernoulliLogit_AR_lp(int[] y, real alpha)
    {
        target += bernoulli_logit_lpmf(y | alpha);
    }
    void sampleBernoulliLogit_AA_lp(int[] y, real[] alpha)
    {
        target += bernoulli_logit_lpmf(y | alpha);
    }
    void sampleBernoulliLogit_AV_lp(int[] y, vector alpha)
    {
        target += bernoulli_logit_lpmf(y | alpha);
    }


    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Categorical distribution
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // y is in {1, ..., K} and theta is a K-simplex (of the probabilities of
    // each of the K outcomes). An N-simplex is a vector (etc.) of non-negative
    // numbers that sum to 1.
    // Note that theta must be vector, not "reals".
    // The logit version is such that categorical_logit_lpmf(beta) is the same
    // as categorical_logit(softmax(beta)), i.e. theta = softmax(beta).

    void sampleCategorical_IV_lp(int y, vector theta)
    {
        target += categorical_lpmf(y | theta);
    }
    void sampleCategorical_AV_lp(int[] y, vector theta)
    {
        target += categorical_lpmf(y | theta);
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Categorical logit distribution
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // y is in {1, ..., K} and beta is a K-vector of (log odds) in the range
    // [-inf, +inf]; theta = softmax(beta) as above.

    void sampleCategoricalLogit_IV_lp(int y, vector beta)
    {
        target += categorical_logit_lpmf(y | beta);
    }
    void sampleCategoricalLogit_AV_lp(int[] y, vector beta)
    {
        target += categorical_logit_lpmf(y | beta);
    }


    // ------------------------------------------------------------------------
    // LOG PROBABILITY FUNCTIONS FOR BRIDGE SAMPLING WITH NON-CENTERED
    // REPARAMETERIZATION
    // ------------------------------------------------------------------------

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Normal distribution, reparameterized to the unit normal distribution
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Compare Stan (2017) manual p299, but we use a bridgesampling version.

    real reparameterizedNormalBoundary(real boundary, real mu, real sigma)
    {
        // boundary: in real-world N(mu, sigma) space
        // return value: equivalent in the reparameterized N(0, 1) space
        return (boundary - mu) / sigma;
    }
    
    // Plain

    real getReparameterizedNormal_RRR_lp(real y_unit_normal, real mu, real sigma)
    {
        real result;
        sampleNormal_RRR_lp(y_unit_normal, 0, 1);
        result = mu + sigma * y_unit_normal;
        return result;
    }
    
    real[] getReparameterizedNormal_ARR_lp(real[] y_unit_normal, real mu, real sigma)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormal_ARA_lp(real[] y_unit_normal, real mu, real[] sigma)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormal_ARV_lp(real[] y_unit_normal, real mu, vector sigma)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormal_AAR_lp(real[] y_unit_normal, real[] mu, real sigma)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormal_AAA_lp(real[] y_unit_normal, real[] mu, real[] sigma)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormal_AAV_lp(real[] y_unit_normal, real[] mu, vector sigma)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormal_AVR_lp(real[] y_unit_normal, vector mu, real sigma)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormal_AVA_lp(real[] y_unit_normal, vector mu, real[] sigma)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormal_AVV_lp(real[] y_unit_normal, vector mu, vector sigma)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[,] getReparameterizedNormal_2RR_lp(real[,] y_unit_normal, real mu, real sigma)
    {
        int dimensions[2] = dims(y_unit_normal);
        real result[dimensions[1], dimensions[2]];
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                sampleNormal_RRR_lp(y_unit_normal[i, j], 0, 1);
                result[i, j] = mu + sigma * y_unit_normal[i, j];
            }
        }
        return result;
    }
    
    real[,,] getReparameterizedNormal_3RR_lp(real[,,] y_unit_normal, real mu, real sigma)
    {
        int dimensions[3] = dims(y_unit_normal);
        real result[dimensions[1], dimensions[2], dimensions[3]];
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    sampleNormal_RRR_lp(y_unit_normal[i, j, k], 0, 1);
                    result[i, j, k] = mu + sigma * y_unit_normal[i, j, k];
                }
            }
        }
        return result;
    }
    
    vector getReparameterizedNormal_VRR_lp(vector y_unit_normal, real mu, real sigma)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormal_VRA_lp(vector y_unit_normal, real mu, real[] sigma)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormal_VRV_lp(vector y_unit_normal, real mu, vector sigma)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormal_VAR_lp(vector y_unit_normal, real[] mu, real sigma)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormal_VAA_lp(vector y_unit_normal, real[] mu, real[] sigma)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormal_VAV_lp(vector y_unit_normal, real[] mu, vector sigma)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormal_VVR_lp(vector y_unit_normal, vector mu, real sigma)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormal_VVA_lp(vector y_unit_normal, vector mu, real[] sigma)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormal_VVV_lp(vector y_unit_normal, vector mu, vector sigma)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleNormal_RRR_lp(y_unit_normal[i], 0, 1);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    // With lower bound

    real getReparameterizedNormalLowerBound_RRR_lp(real y_unit_normal, real mu, real sigma, real lower)
    {
        real result;
        real lower_transformed;
        lower_transformed = (lower - mu) / sigma;
        sampleNormalLowerBound_RRR_lp(y_unit_normal, 0, 1, lower_transformed);
        result = mu + sigma * y_unit_normal;
        return result;
    }
    
    real[] getReparameterizedNormalLowerBound_ARR_lp(real[] y_unit_normal, real mu, real sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma;
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalLowerBound_ARA_lp(real[] y_unit_normal, real mu, real[] sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalLowerBound_ARV_lp(real[] y_unit_normal, real mu, vector sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalLowerBound_AAR_lp(real[] y_unit_normal, real[] mu, real sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma;
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalLowerBound_AAA_lp(real[] y_unit_normal, real[] mu, real[] sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalLowerBound_AAV_lp(real[] y_unit_normal, real[] mu, vector sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalLowerBound_AVR_lp(real[] y_unit_normal, vector mu, real sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma;
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalLowerBound_AVA_lp(real[] y_unit_normal, vector mu, real[] sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalLowerBound_AVV_lp(real[] y_unit_normal, vector mu, vector sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[,] getReparameterizedNormalLowerBound_2RR_lp(real[,] y_unit_normal, real mu, real sigma, real lower)
    {
        int dimensions[2] = dims(y_unit_normal);
        real result[dimensions[1], dimensions[2]];
        real lower_transformed;
        lower_transformed = (lower - mu) / sigma;
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                sampleNormalLowerBound_RRR_lp(y_unit_normal[i, j], 0, 1, lower_transformed);
                result[i, j] = mu + sigma * y_unit_normal[i, j];
            }
        }
        return result;
    }
    
    real[,,] getReparameterizedNormalLowerBound_3RR_lp(real[,,] y_unit_normal, real mu, real sigma, real lower)
    {
        int dimensions[3] = dims(y_unit_normal);
        real result[dimensions[1], dimensions[2], dimensions[3]];
        real lower_transformed;
        lower_transformed = (lower - mu) / sigma;
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    sampleNormalLowerBound_RRR_lp(y_unit_normal[i, j, k], 0, 1, lower_transformed);
                    result[i, j, k] = mu + sigma * y_unit_normal[i, j, k];
                }
            }
        }
        return result;
    }
    
    vector getReparameterizedNormalLowerBound_VRR_lp(vector y_unit_normal, real mu, real sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma;
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalLowerBound_VRA_lp(vector y_unit_normal, real mu, real[] sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalLowerBound_VRV_lp(vector y_unit_normal, real mu, vector sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalLowerBound_VAR_lp(vector y_unit_normal, real[] mu, real sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma;
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalLowerBound_VAA_lp(vector y_unit_normal, real[] mu, real[] sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalLowerBound_VAV_lp(vector y_unit_normal, real[] mu, vector sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalLowerBound_VVR_lp(vector y_unit_normal, vector mu, real sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma;
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalLowerBound_VVA_lp(vector y_unit_normal, vector mu, real[] sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalLowerBound_VVV_lp(vector y_unit_normal, vector mu, vector sigma, real lower)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            sampleNormalLowerBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    // With upper bound

    real getReparameterizedNormalUpperBound_RRR_lp(real y_unit_normal, real mu, real sigma, real upper)
    {
        real result;
        real upper_transformed;
        upper_transformed = (upper - mu) / sigma;
        sampleNormalUpperBound_RRR_lp(y_unit_normal, 0, 1, upper_transformed);
        result = mu + sigma * y_unit_normal;
        return result;
    }
    
    real[] getReparameterizedNormalUpperBound_ARR_lp(real[] y_unit_normal, real mu, real sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real upper_transformed;
        for (i in 1:length) {
            upper_transformed = (upper - mu) / sigma;
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalUpperBound_ARA_lp(real[] y_unit_normal, real mu, real[] sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalUpperBound_ARV_lp(real[] y_unit_normal, real mu, vector sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalUpperBound_AAR_lp(real[] y_unit_normal, real[] mu, real sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma;
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalUpperBound_AAA_lp(real[] y_unit_normal, real[] mu, real[] sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalUpperBound_AAV_lp(real[] y_unit_normal, real[] mu, vector sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalUpperBound_AVR_lp(real[] y_unit_normal, vector mu, real sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma;
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalUpperBound_AVA_lp(real[] y_unit_normal, vector mu, real[] sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalUpperBound_AVV_lp(real[] y_unit_normal, vector mu, vector sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[,] getReparameterizedNormalUpperBound_2RR_lp(real[,] y_unit_normal, real mu, real sigma, real upper)
    {
        int dimensions[2] = dims(y_unit_normal);
        real result[dimensions[1], dimensions[2]];
        real upper_transformed;
        upper_transformed = (upper - mu) / sigma;
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                sampleNormalUpperBound_RRR_lp(y_unit_normal[i, j], 0, 1, upper_transformed);
                result[i, j] = mu + sigma * y_unit_normal[i, j];
            }
        }
        return result;
    }
    
    real[,,] getReparameterizedNormalUpperBound_3RR_lp(real[,,] y_unit_normal, real mu, real sigma, real upper)
    {
        int dimensions[3] = dims(y_unit_normal);
        real result[dimensions[1], dimensions[2], dimensions[3]];
        real upper_transformed;
        upper_transformed = (upper - mu) / sigma;
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    sampleNormalUpperBound_RRR_lp(y_unit_normal[i, j, k], 0, 1, upper_transformed);
                    result[i, j, k] = mu + sigma * y_unit_normal[i, j, k];
                }
            }
        }
        return result;
    }
    
    vector getReparameterizedNormalUpperBound_VRR_lp(vector y_unit_normal, real mu, real sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real upper_transformed;
        for (i in 1:length) {
            upper_transformed = (upper - mu) / sigma;
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalUpperBound_VRA_lp(vector y_unit_normal, real mu, real[] sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalUpperBound_VRV_lp(vector y_unit_normal, real mu, vector sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalUpperBound_VAR_lp(vector y_unit_normal, real[] mu, real sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma;
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalUpperBound_VAA_lp(vector y_unit_normal, real[] mu, real[] sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalUpperBound_VAV_lp(vector y_unit_normal, real[] mu, vector sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalUpperBound_VVR_lp(vector y_unit_normal, vector mu, real sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma;
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalUpperBound_VVA_lp(vector y_unit_normal, vector mu, real[] sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalUpperBound_VVV_lp(vector y_unit_normal, vector mu, vector sigma, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalUpperBound_RRR_lp(y_unit_normal[i], 0, 1, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    // With range (lower and upper) bounds

    real getReparameterizedNormalRangeBound_RRR_lp(real y_unit_normal, real mu, real sigma, real lower, real upper)
    {
        real result;
        real lower_transformed;
        real upper_transformed;
        lower_transformed = (lower - mu) / sigma;
        upper_transformed = (upper - mu) / sigma;
        sampleNormalRangeBound_RRR_lp(y_unit_normal, 0, 1, lower_transformed, upper_transformed);
        result = mu + sigma * y_unit_normal;
        return result;
    }
    
    real[] getReparameterizedNormalRangeBound_ARR_lp(real[] y_unit_normal, real mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma;
            upper_transformed = (upper - mu) / sigma;
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalRangeBound_ARA_lp(real[] y_unit_normal, real mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma[i];
            upper_transformed = (upper - mu) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalRangeBound_ARV_lp(real[] y_unit_normal, real mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma[i];
            upper_transformed = (upper - mu) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalRangeBound_AAR_lp(real[] y_unit_normal, real[] mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma;
            upper_transformed = (upper - mu[i]) / sigma;
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalRangeBound_AAA_lp(real[] y_unit_normal, real[] mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalRangeBound_AAV_lp(real[] y_unit_normal, real[] mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalRangeBound_AVR_lp(real[] y_unit_normal, vector mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma;
            upper_transformed = (upper - mu[i]) / sigma;
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalRangeBound_AVA_lp(real[] y_unit_normal, vector mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[] getReparameterizedNormalRangeBound_AVV_lp(real[] y_unit_normal, vector mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    real[,] getReparameterizedNormalRangeBound_2RR_lp(real[,] y_unit_normal, real mu, real sigma, real lower, real upper)
    {
        int dimensions[2] = dims(y_unit_normal);
        real result[dimensions[1], dimensions[2]];
        real lower_transformed;
        real upper_transformed;
        lower_transformed = (lower - mu) / sigma;
        upper_transformed = (upper - mu) / sigma;
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                sampleNormalRangeBound_RRR_lp(y_unit_normal[i, j], 0, 1, lower_transformed, upper_transformed);
                result[i, j] = mu + sigma * y_unit_normal[i, j];
            }
        }
        return result;
    }
    
    real[,,] getReparameterizedNormalRangeBound_3RR_lp(real[,,] y_unit_normal, real mu, real sigma, real lower, real upper)
    {
        int dimensions[3] = dims(y_unit_normal);
        real result[dimensions[1], dimensions[2], dimensions[3]];
        real lower_transformed;
        real upper_transformed;
        lower_transformed = (lower - mu) / sigma;
        upper_transformed = (upper - mu) / sigma;
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    sampleNormalRangeBound_RRR_lp(y_unit_normal[i, j, k], 0, 1, lower_transformed, upper_transformed);
                    result[i, j, k] = mu + sigma * y_unit_normal[i, j, k];
                }
            }
        }
        return result;
    }
    
    vector getReparameterizedNormalRangeBound_VRR_lp(vector y_unit_normal, real mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma;
            upper_transformed = (upper - mu) / sigma;
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalRangeBound_VRA_lp(vector y_unit_normal, real mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma[i];
            upper_transformed = (upper - mu) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalRangeBound_VRV_lp(vector y_unit_normal, real mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu) / sigma[i];
            upper_transformed = (upper - mu) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalRangeBound_VAR_lp(vector y_unit_normal, real[] mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma;
            upper_transformed = (upper - mu[i]) / sigma;
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalRangeBound_VAA_lp(vector y_unit_normal, real[] mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalRangeBound_VAV_lp(vector y_unit_normal, real[] mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalRangeBound_VVR_lp(vector y_unit_normal, vector mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma;
            upper_transformed = (upper - mu[i]) / sigma;
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalRangeBound_VVA_lp(vector y_unit_normal, vector mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    vector getReparameterizedNormalRangeBound_VVV_lp(vector y_unit_normal, vector mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_unit_normal);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = (lower - mu[i]) / sigma[i];
            upper_transformed = (upper - mu[i]) / sigma[i];
            sampleNormalRangeBound_RRR_lp(y_unit_normal[i], 0, 1, lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * y_unit_normal[i];
        }
        return result;
    }
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Cauchy distribution, reparameterized to the uniform distribution
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    /*
    See p339 of the Stan (2017) manual.
    The transformation is

        y_cauchy(mu, sigma) = mu + sigma * y_uniform(-pi/2, pi/2)

    so the boundary transformation is the reverse, namely

        uniform_boundary = arctan((boundary - mu) / sigma)

    Note that
        arctan(-infinity) is -pi/2; arctan(0) is 0; arctan(infinity) is pi/2
        ... so for lower == 0, lower_transformed == 0

    We can do the range constraints like this:
         real<lower=-pi()/2, upper=pi()/2> y_uniform;  // Cauchy
         real<lower=0, upper=pi()/2> y_uniform;  // positive half-Cauchy
    and the sampling statement would be unnecessary, but we're going to
    to the sampling using "target +=" so that bridgesampling works.

    You might think that because of that, the range constraint is unnecessary,
    but it IS STILL NECESSARY or Stan will explore invalid ranges.

    */

    real reparameterizedCauchyBoundary(real boundary, real mu, real sigma)
    {
        // boundary: in real-world Cauchy(mu, sigma) space
        // return value: equivalent in the reparameterized uniform [-pi/2, +pi/2] space
        return atan((boundary - mu) / sigma);
    }
    
    // Plain

    real getReparameterizedCauchy_RRR_lp(real y_uniform, real mu, real sigma)
    {
        real result;
        sampleUniform_RRR_lp(y_uniform, -pi()/2, pi()/2);
        result = mu + sigma * tan(y_uniform);
        return result;
    }
    
    real[] getReparameterizedCauchy_ARR_lp(real[] y_uniform, real mu, real sigma)
    {
        int length = num_elements(y_uniform);
        real result[length];
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchy_ARA_lp(real[] y_uniform, real mu, real[] sigma)
    {
        int length = num_elements(y_uniform);
        real result[length];
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchy_ARV_lp(real[] y_uniform, real mu, vector sigma)
    {
        int length = num_elements(y_uniform);
        real result[length];
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchy_AAR_lp(real[] y_uniform, real[] mu, real sigma)
    {
        int length = num_elements(y_uniform);
        real result[length];
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchy_AAA_lp(real[] y_uniform, real[] mu, real[] sigma)
    {
        int length = num_elements(y_uniform);
        real result[length];
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchy_AAV_lp(real[] y_uniform, real[] mu, vector sigma)
    {
        int length = num_elements(y_uniform);
        real result[length];
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchy_AVR_lp(real[] y_uniform, vector mu, real sigma)
    {
        int length = num_elements(y_uniform);
        real result[length];
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchy_AVA_lp(real[] y_uniform, vector mu, real[] sigma)
    {
        int length = num_elements(y_uniform);
        real result[length];
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchy_AVV_lp(real[] y_uniform, vector mu, vector sigma)
    {
        int length = num_elements(y_uniform);
        real result[length];
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[,] getReparameterizedCauchy_2RR_lp(real[,] y_uniform, real mu, real sigma)
    {
        int dimensions[2] = dims(y_uniform);
        real result[dimensions[1], dimensions[2]];
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                sampleUniform_RRR_lp(y_uniform[i, j], -pi()/2, pi()/2);
                result[i, j] = mu + sigma * tan(y_uniform[i, j]);
            }
        }
        return result;
    }
    
    real[,,] getReparameterizedCauchy_3RR_lp(real[,,] y_uniform, real mu, real sigma)
    {
        int dimensions[3] = dims(y_uniform);
        real result[dimensions[1], dimensions[2], dimensions[3]];
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    sampleUniform_RRR_lp(y_uniform[i, j, k], -pi()/2, pi()/2);
                    result[i, j, k] = mu + sigma * tan(y_uniform[i, j, k]);
                }
            }
        }
        return result;
    }
    
    vector getReparameterizedCauchy_VRR_lp(vector y_uniform, real mu, real sigma)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchy_VRA_lp(vector y_uniform, real mu, real[] sigma)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchy_VRV_lp(vector y_uniform, real mu, vector sigma)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchy_VAR_lp(vector y_uniform, real[] mu, real sigma)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchy_VAA_lp(vector y_uniform, real[] mu, real[] sigma)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchy_VAV_lp(vector y_uniform, real[] mu, vector sigma)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchy_VVR_lp(vector y_uniform, vector mu, real sigma)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchy_VVA_lp(vector y_uniform, vector mu, real[] sigma)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchy_VVV_lp(vector y_uniform, vector mu, vector sigma)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    // With lower bound

    real getReparameterizedCauchyLowerBound_RRR_lp(real y_uniform, real mu, real sigma, real lower)
    {
        real result;
        real lower_transformed;
        lower_transformed = atan((lower - mu) / sigma);
        sampleUniform_RRR_lp(y_uniform, lower_transformed, pi()/2);
        result = mu + sigma * tan(y_uniform);
        return result;
    }
    
    real[] getReparameterizedCauchyLowerBound_ARR_lp(real[] y_uniform, real mu, real sigma, real lower)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyLowerBound_ARA_lp(real[] y_uniform, real mu, real[] sigma, real lower)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyLowerBound_ARV_lp(real[] y_uniform, real mu, vector sigma, real lower)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyLowerBound_AAR_lp(real[] y_uniform, real[] mu, real sigma, real lower)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyLowerBound_AAA_lp(real[] y_uniform, real[] mu, real[] sigma, real lower)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyLowerBound_AAV_lp(real[] y_uniform, real[] mu, vector sigma, real lower)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyLowerBound_AVR_lp(real[] y_uniform, vector mu, real sigma, real lower)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyLowerBound_AVA_lp(real[] y_uniform, vector mu, real[] sigma, real lower)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyLowerBound_AVV_lp(real[] y_uniform, vector mu, vector sigma, real lower)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[,] getReparameterizedCauchyLowerBound_2RR_lp(real[,] y_uniform, real mu, real sigma, real lower)
    {
        int dimensions[2] = dims(y_uniform);
        real result[dimensions[1], dimensions[2]];
        real lower_transformed;
        lower_transformed = atan((lower - mu) / sigma);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                sampleUniform_RRR_lp(y_uniform[i, j], lower_transformed, pi()/2);
                result[i, j] = mu + sigma * tan(y_uniform[i, j]);
            }
        }
        return result;
    }
    
    real[,,] getReparameterizedCauchyLowerBound_3RR_lp(real[,,] y_uniform, real mu, real sigma, real lower)
    {
        int dimensions[3] = dims(y_uniform);
        real result[dimensions[1], dimensions[2], dimensions[3]];
        real lower_transformed;
        lower_transformed = atan((lower - mu) / sigma);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    sampleUniform_RRR_lp(y_uniform[i, j, k], lower_transformed, pi()/2);
                    result[i, j, k] = mu + sigma * tan(y_uniform[i, j, k]);
                }
            }
        }
        return result;
    }
    
    vector getReparameterizedCauchyLowerBound_VRR_lp(vector y_uniform, real mu, real sigma, real lower)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyLowerBound_VRA_lp(vector y_uniform, real mu, real[] sigma, real lower)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyLowerBound_VRV_lp(vector y_uniform, real mu, vector sigma, real lower)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyLowerBound_VAR_lp(vector y_uniform, real[] mu, real sigma, real lower)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyLowerBound_VAA_lp(vector y_uniform, real[] mu, real[] sigma, real lower)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyLowerBound_VAV_lp(vector y_uniform, real[] mu, vector sigma, real lower)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyLowerBound_VVR_lp(vector y_uniform, vector mu, real sigma, real lower)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyLowerBound_VVA_lp(vector y_uniform, vector mu, real[] sigma, real lower)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyLowerBound_VVV_lp(vector y_uniform, vector mu, vector sigma, real lower)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, pi()/2);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    // With upper bound

    real getReparameterizedCauchyUpperBound_RRR_lp(real y_uniform, real mu, real sigma, real upper)
    {
        real result;
        real upper_transformed;
        upper_transformed = atan((upper - mu) / sigma);
        sampleUniform_RRR_lp(y_uniform, -pi()/2, upper_transformed);
        result = mu + sigma * tan(y_uniform);
        return result;
    }
    
    real[] getReparameterizedCauchyUpperBound_ARR_lp(real[] y_uniform, real mu, real sigma, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real upper_transformed;
        for (i in 1:length) {
            upper_transformed = atan((upper - mu) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyUpperBound_ARA_lp(real[] y_uniform, real mu, real[] sigma, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyUpperBound_ARV_lp(real[] y_uniform, real mu, vector sigma, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyUpperBound_AAR_lp(real[] y_uniform, real[] mu, real sigma, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyUpperBound_AAA_lp(real[] y_uniform, real[] mu, real[] sigma, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyUpperBound_AAV_lp(real[] y_uniform, real[] mu, vector sigma, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyUpperBound_AVR_lp(real[] y_uniform, vector mu, real sigma, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyUpperBound_AVA_lp(real[] y_uniform, vector mu, real[] sigma, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyUpperBound_AVV_lp(real[] y_uniform, vector mu, vector sigma, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[,] getReparameterizedCauchyUpperBound_2RR_lp(real[,] y_uniform, real mu, real sigma, real upper)
    {
        int dimensions[2] = dims(y_uniform);
        real result[dimensions[1], dimensions[2]];
        real upper_transformed;
        upper_transformed = atan((upper - mu) / sigma);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                sampleUniform_RRR_lp(y_uniform[i, j], -pi()/2, upper_transformed);
                result[i, j] = mu + sigma * tan(y_uniform[i, j]);
            }
        }
        return result;
    }
    
    real[,,] getReparameterizedCauchyUpperBound_3RR_lp(real[,,] y_uniform, real mu, real sigma, real upper)
    {
        int dimensions[3] = dims(y_uniform);
        real result[dimensions[1], dimensions[2], dimensions[3]];
        real upper_transformed;
        upper_transformed = atan((upper - mu) / sigma);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    sampleUniform_RRR_lp(y_uniform[i, j, k], -pi()/2, upper_transformed);
                    result[i, j, k] = mu + sigma * tan(y_uniform[i, j, k]);
                }
            }
        }
        return result;
    }
    
    vector getReparameterizedCauchyUpperBound_VRR_lp(vector y_uniform, real mu, real sigma, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real upper_transformed;
        for (i in 1:length) {
            upper_transformed = atan((upper - mu) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyUpperBound_VRA_lp(vector y_uniform, real mu, real[] sigma, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyUpperBound_VRV_lp(vector y_uniform, real mu, vector sigma, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyUpperBound_VAR_lp(vector y_uniform, real[] mu, real sigma, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyUpperBound_VAA_lp(vector y_uniform, real[] mu, real[] sigma, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyUpperBound_VAV_lp(vector y_uniform, real[] mu, vector sigma, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyUpperBound_VVR_lp(vector y_uniform, vector mu, real sigma, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyUpperBound_VVA_lp(vector y_uniform, vector mu, real[] sigma, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyUpperBound_VVV_lp(vector y_uniform, vector mu, vector sigma, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], -pi()/2, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    // With range (lower and upper) bounds

    real getReparameterizedCauchyRangeBound_RRR_lp(real y_uniform, real mu, real sigma, real lower, real upper)
    {
        real result;
        real lower_transformed;
        real upper_transformed;
        lower_transformed = atan((lower - mu) / sigma);
        upper_transformed = atan((upper - mu) / sigma);
        sampleUniform_RRR_lp(y_uniform, lower_transformed, upper_transformed);
        result = mu + sigma * tan(y_uniform);
        return result;
    }
    
    real[] getReparameterizedCauchyRangeBound_ARR_lp(real[] y_uniform, real mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma);
            upper_transformed = atan((upper - mu) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyRangeBound_ARA_lp(real[] y_uniform, real mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma[i]);
            upper_transformed = atan((upper - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyRangeBound_ARV_lp(real[] y_uniform, real mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma[i]);
            upper_transformed = atan((upper - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyRangeBound_AAR_lp(real[] y_uniform, real[] mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma);
            upper_transformed = atan((upper - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyRangeBound_AAA_lp(real[] y_uniform, real[] mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyRangeBound_AAV_lp(real[] y_uniform, real[] mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyRangeBound_AVR_lp(real[] y_uniform, vector mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma);
            upper_transformed = atan((upper - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyRangeBound_AVA_lp(real[] y_uniform, vector mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[] getReparameterizedCauchyRangeBound_AVV_lp(real[] y_uniform, vector mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        real result[length];
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    real[,] getReparameterizedCauchyRangeBound_2RR_lp(real[,] y_uniform, real mu, real sigma, real lower, real upper)
    {
        int dimensions[2] = dims(y_uniform);
        real result[dimensions[1], dimensions[2]];
        real lower_transformed;
        real upper_transformed;
        lower_transformed = atan((lower - mu) / sigma);
        upper_transformed = atan((upper - mu) / sigma);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                sampleUniform_RRR_lp(y_uniform[i, j], lower_transformed, upper_transformed);
                result[i, j] = mu + sigma * tan(y_uniform[i, j]);
            }
        }
        return result;
    }
    
    real[,,] getReparameterizedCauchyRangeBound_3RR_lp(real[,,] y_uniform, real mu, real sigma, real lower, real upper)
    {
        int dimensions[3] = dims(y_uniform);
        real result[dimensions[1], dimensions[2], dimensions[3]];
        real lower_transformed;
        real upper_transformed;
        lower_transformed = atan((lower - mu) / sigma);
        upper_transformed = atan((upper - mu) / sigma);
        for (i in 1:dimensions[1]) {
            for (j in 1:dimensions[2]) {
                for (k in 1:dimensions[3]) {
                    sampleUniform_RRR_lp(y_uniform[i, j, k], lower_transformed, upper_transformed);
                    result[i, j, k] = mu + sigma * tan(y_uniform[i, j, k]);
                }
            }
        }
        return result;
    }
    
    vector getReparameterizedCauchyRangeBound_VRR_lp(vector y_uniform, real mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma);
            upper_transformed = atan((upper - mu) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyRangeBound_VRA_lp(vector y_uniform, real mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma[i]);
            upper_transformed = atan((upper - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyRangeBound_VRV_lp(vector y_uniform, real mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu) / sigma[i]);
            upper_transformed = atan((upper - mu) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyRangeBound_VAR_lp(vector y_uniform, real[] mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma);
            upper_transformed = atan((upper - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyRangeBound_VAA_lp(vector y_uniform, real[] mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyRangeBound_VAV_lp(vector y_uniform, real[] mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyRangeBound_VVR_lp(vector y_uniform, vector mu, real sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma);
            upper_transformed = atan((upper - mu[i]) / sigma);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyRangeBound_VVA_lp(vector y_uniform, vector mu, real[] sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    vector getReparameterizedCauchyRangeBound_VVV_lp(vector y_uniform, vector mu, vector sigma, real lower, real upper)
    {
        int length = num_elements(y_uniform);
        vector[length] result;
        real lower_transformed;
        real upper_transformed;
        if (num_elements(mu) != length || num_elements(sigma) != length) {
            reject("Incompatible arguments");
        }
        for (i in 1:length) {
            lower_transformed = atan((lower - mu[i]) / sigma[i]);
            upper_transformed = atan((upper - mu[i]) / sigma[i]);
            sampleUniform_RRR_lp(y_uniform[i], lower_transformed, upper_transformed);
            result[i] = mu[i] + sigma[i] * tan(y_uniform[i]);
        }
        return result;
    }
    
    // ------------------------------------------------------------------------
    // ANOVA-type designs: DEPRECATED APPROACH
    // ------------------------------------------------------------------------
    // ... rather than coding intercept + main effects + interactions (etc.),
    // as here, it's probably best to code individual cells. That makes
    // distributions more sensible (and predictable/easily calculable).

    int interactionIndex2Way(int first_index, int first_max,
                             int second_index, int second_max)
    {
        /*
            Because Stan doesn't support sampling into matrix, we need to
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            convert matrix-like concepts to vectors. Specifically, it doesn't
            support either
                matrix[A, B] m;
                m ~ normal(0, 0.5);  // error: "no matches for matrix ~ normal(int, real)"
            or
                real a[A, B];
                a ~ normal(0, 0.5);  // error: "no matches for real[,] ~ normal(int, real)"

            And note that a vectorized sampling statement is strongly preferred
            (for performance reasons) over iterating through a matrix:
                https://groups.google.com/forum/#!topic/stan-users/4gv3fNCqSNk
                    "Do not loop over sampling statements when a vectorized
                    sampling statement is possible"

            So we use a vector of size A*B, and this index lookup function.
            Parameters:
            - first_index is from 1 to first_max
            - second_index is from 1 to second_max
            - We want a consecutive index from 1 to (first_max * second_max)

            In the output, the FIRST will cycle LEAST rapidly, and the
            LAST will cycle MOST rapidly.
        */
        return (
            (first_index - 1) * first_max +     // slow cycling
            second_index                        // fast cycling
        );
    }

    vector setLastForZeroSum(vector params)
    {
        /*
            Makes a vector of parameters sum to zero, by setting the last
            element to the negative sum of the others.
            Used for ANOVA-style effects; e.g. if you have a grand mean, you
            might specify the effects of a three-level factor A as A1, A2, A3;
            then A1 + A2 + A3 must be zero, so A1 and A2 are free parameters
            that are drawn from an appropriate distribution, and then A3 is
            fully constrainted to be -(A1 + A2).

            Because we can't modify the input parameters, we make a new copy.

            Returns a vector of the SAME LENGTH as the original.
            (The last element of the incoming vector is ignored.)
        */
        int length = num_elements(params);
        vector[length] newparams;
        real total = 0.0;
        real value;
        for (i in 1:length - 1) {
            value = params[i];
            newparams[i] = value;
            total = total + value;
        }
        newparams[length] = -total;
        return newparams;
    }

    vector appendElementForZeroSum(vector params)
    {
        /*
            As for setLastForZeroSum(), but uses all the information in the
            incoming vector, and returns a vector that's one element longer.
        */
        int initial_length = num_elements(params);
        int new_length = initial_length + 1;
        vector[new_length] newparams;
        real total = 0.0;
        real value;
        for (i in 1:initial_length) {
            value = params[i];
            newparams[i] = value;
            total = total + value;
        }
        newparams[new_length] = -total;
        return newparams;
    }
